"""
{{ wf_name }} workflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
生成时间: {{ timestamp }}

1. 在 **TOOLS** 区域定义需要暴露给 Prompt 的前置工具
2. 在 **NODES**  区域实现异步节点函数 (await-able)
3. 在 **EDGES**  区域声明有向边
4. 最后返回 builder.compile() 或 GenericGraphBuilder
"""

from __future__ import annotations
import json
from dataclasses import Field
from pydantic import BaseModel
from dataflow_agent.state import xxState
from dataflow_agent.graghbuilder.gragh_builder import GenericGraphBuilder
from dataflow_agent.workflow.registry import register
from dataflow_agent.agentroles import get_agent_cls, create_agent

from dataflow_agent.toolkits.tool_manager import get_tool_manager
from langchain.tools import tool
from langgraph.graph import StateGraph
from langgraph.prebuilt import ToolNode, tools_condition

from dataflow_agent.graghbuilder.gragh_builder import GenericGraphBuilder
from dataflow_agent.logger import get_logger

log = get_logger(__name__)

@register("{{ wf_name }}")
def create_{{ wf_name_snake }}_graph() -> GenericGraphBuilder:  # noqa: N802
    """
    Workflow factory: dfa run --wf {{ wf_name }}
    """
    builder = GenericGraphBuilder(state_model=xxState,
                                  entry_point="{{ entry }}")  # 自行修改入口

    # ----------------------------------------------------------------------
    # TOOLS (pre_tool definitions)
    # ----------------------------------------------------------------------
    # 例:
    @builder.pre_tool("purpose", "step1")
    def _purpose(state: xxState):
        return "这里放入字符串 / 数值 / 列表 / 字典等供 prompt 使用"

    # 后置工具就是让agent选择的工具，可以定制多个；
    class ModuleListInput(BaseModel):
        #这里要写好工具的描述，agent会根据实际上下文输入参数：
        module_list: list = Field(
            description="List of dotted-path python modules or file paths"
        )
    @builder.post_tool("step2")
    @tool(args_schema=ModuleListInput)
    def _post_tool1(module_list):
        return func(module_list)

    # ----------------------------------------------------------------------

    # ==============================================================
    # NODES
    # ==============================================================
    async def step1(state: xxState) -> xxState:
        """
        示例节点 1: 使用 create_agent 创建并执行agent
        
        Args:
            model_name: 模型名称，如 "gpt-4"
            temperature: 采样温度，控制随机性 (0.0-1.0)
            max_tokens: 最大生成token数
            tool_mode: 工具调用模式 ("auto", "none", "required")
            react_mode: 是否启用ReAct推理模式
            react_max_retries: ReAct模式下最大重试次数
            parser_type: 解析器类型 ("json", "xml", "text")，这个允许你在提示词中定义LLM不同的返回，xml还是json，还是直出；
            parser_config: 解析器配置字典（如XML的root_tag）
            use_vlm: 是否使用视觉语言模型，使用了视觉模型，其余的参数失效；
            vlm_config: VLM配置字典
            **kwargs: 其他传递给init的参数
        """
        # 创建agent实例
        agent = create_agent(
            name="your_agent_name",  # 替换为实际的agent名称
            model_name="gpt-4",      # 模型名称
            temperature=0.7,         # 采样温度
            max_tokens=4096,         # 最大token数
            tool_mode="auto",        # 工具调用模式
            react_mode=True,         # 启用ReAct推理
            react_max_retries=3,     # 最大重试次数
            parser_type="json",     # 解析器类型
        )
        
        # 执行agent             use_agent: 是否使用agent模式
        state = await agent.execute(state=state, use_agent=False)
        return state

    async def step2(state: xxState) -> xxState:
        """
        示例节点 2: 处理agent执行结果
        
        Args:
            state: 主状态对象
        """
        # TODO: 替换为真正的业务逻辑
        state.agent_results["step2"] = {"msg": "hello step2"}
        return state

    # ==============================================================
    # 注册 nodes / edges
    # ==============================================================
    nodes = {
        "step1": step1,
        "step2": step2,
        '_end_': lambda state: state,  # 终止节点
    }

    # ------------------------------------------------------------------
    # EDGES  (从节点 A 指向节点 B)
    # ------------------------------------------------------------------
    edges = [
        ("step1", "step2"),
        ("step2", "_end_"),  # 指向终止节点
    ]

    builder.add_nodes(nodes).add_edges(edges)
    return builder