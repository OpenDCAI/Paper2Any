{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Setup Supabase Project with Minimal Schema",
        "description": "Create Supabase project and implement the minimal database schema with only 2 custom tables (usage_records, user_files) plus RLS policies as specified in the PRD.",
        "details": "## Implementation Steps\n\n1. **Create Supabase Project**\n   - Sign up at supabase.com and create a new project\n   - Save credentials: project URL, anon key, service role key, JWT secret\n\n2. **Run Database Migration in SQL Editor**\n\n```sql\n-- Track daily usage per user\nCREATE TABLE usage_records (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  workflow_type TEXT NOT NULL,\n  called_at TIMESTAMPTZ DEFAULT now()\n);\n\n-- Create index for efficient daily queries\nCREATE INDEX idx_usage_records_user_date ON usage_records(user_id, DATE(called_at));\n\n-- Track user files\nCREATE TABLE user_files (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  file_path TEXT NOT NULL,\n  file_name TEXT NOT NULL,\n  file_size BIGINT,\n  workflow_type TEXT,\n  created_at TIMESTAMPTZ DEFAULT now()\n);\n\n-- Enable RLS\nALTER TABLE usage_records ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_files ENABLE ROW LEVEL SECURITY;\n\n-- RLS Policies\nCREATE POLICY \"Users read own usage\" ON usage_records FOR SELECT USING (auth.uid() = user_id);\nCREATE POLICY \"Users insert own usage\" ON usage_records FOR INSERT WITH CHECK (auth.uid() = user_id);\nCREATE POLICY \"Users read own files\" ON user_files FOR ALL USING (auth.uid() = user_id);\n```\n\n3. **Create Storage Bucket**\n   - Create bucket named `user-files` in Supabase Storage\n   - Set storage policies:\n\n```sql\nCREATE POLICY \"Users upload own files\" ON storage.objects \n  FOR INSERT WITH CHECK (\n    bucket_id = 'user-files' AND \n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users read own files\" ON storage.objects \n  FOR SELECT USING (\n    bucket_id = 'user-files' AND \n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users delete own files\" ON storage.objects \n  FOR DELETE USING (\n    bucket_id = 'user-files' AND \n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n```\n\n4. **Note environment variables needed**\n   - SUPABASE_URL\n   - SUPABASE_ANON_KEY\n   - SUPABASE_SERVICE_ROLE_KEY\n   - SUPABASE_JWT_SECRET (from Project Settings > API > JWT Secret)",
        "testStrategy": "1. Verify tables exist via Supabase dashboard table view\n2. Test RLS by creating test user and attempting cross-user data access (should fail)\n3. Test storage bucket upload/download with authenticated user\n4. Verify indexes exist: SELECT indexname FROM pg_indexes WHERE tablename = 'usage_records'",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Supabase Project and Save Credentials",
            "description": "Create a new Supabase project at supabase.com, configure basic project settings, and document all credentials needed for backend and frontend integration.",
            "dependencies": [],
            "details": "Sign up/login at supabase.com and create a new project named 'dataflow-agent' or similar. Wait for project provisioning (1-2 min). Navigate to Project Settings > API to collect: Project URL (SUPABASE_URL), anon/public key (SUPABASE_ANON_KEY), service_role key (SUPABASE_SERVICE_ROLE_KEY), and JWT Secret (SUPABASE_JWT_SECRET). Create .env.example files in both project root (for FastAPI) and frontend-workflow/ (for Vite with VITE_ prefix). Document in CLAUDE.md or local notes. Do NOT commit actual credentials.",
            "status": "pending",
            "testStrategy": "Verify all 4 credentials are accessible in Supabase dashboard. Test anon key format starts with 'eyJ'. Confirm .env.example files list all required variables without actual values."
          },
          {
            "id": 2,
            "title": "Execute Database Migration for usage_records and user_files Tables",
            "description": "Run SQL migration in Supabase SQL Editor to create the two custom tables (usage_records, user_files) with proper foreign keys referencing auth.users.",
            "dependencies": [
              1
            ],
            "details": "In Supabase Dashboard > SQL Editor, run migration script: CREATE TABLE usage_records with columns (id UUID PK, user_id UUID FK to auth.users ON DELETE CASCADE, workflow_type TEXT NOT NULL, called_at TIMESTAMPTZ DEFAULT now()). CREATE INDEX idx_usage_records_user_date ON usage_records(user_id, DATE(called_at)) for efficient daily count queries. CREATE TABLE user_files with columns (id UUID PK, user_id UUID FK, file_path TEXT NOT NULL, file_name TEXT NOT NULL, file_size BIGINT, workflow_type TEXT, created_at TIMESTAMPTZ DEFAULT now()). Save migration script to fastapi_app/migrations/001_initial_schema.sql for version control.",
            "status": "pending",
            "testStrategy": "Verify tables exist via Supabase Dashboard > Table Editor. Run SELECT * FROM usage_records LIMIT 1 and SELECT * FROM user_files LIMIT 1 - should return empty results without errors. Verify foreign key constraint: SELECT conname FROM pg_constraint WHERE conrelid = 'usage_records'::regclass."
          },
          {
            "id": 3,
            "title": "Enable RLS and Create Security Policies for Both Tables",
            "description": "Enable Row Level Security on usage_records and user_files tables, then create policies ensuring users can only access their own data.",
            "dependencies": [
              2
            ],
            "details": "In Supabase SQL Editor, run: ALTER TABLE usage_records ENABLE ROW LEVEL SECURITY; ALTER TABLE user_files ENABLE ROW LEVEL SECURITY; CREATE POLICY 'Users read own usage' ON usage_records FOR SELECT USING (auth.uid() = user_id); CREATE POLICY 'Users insert own usage' ON usage_records FOR INSERT WITH CHECK (auth.uid() = user_id); CREATE POLICY 'Users read own files' ON user_files FOR ALL USING (auth.uid() = user_id); This ensures complete data isolation between users without backend logic changes. Save policy SQL to fastapi_app/migrations/002_rls_policies.sql.",
            "status": "pending",
            "testStrategy": "Create test user via Supabase Auth dashboard or API. Insert test record with that user_id. Create second test user. Attempt to SELECT the first user's records while authenticated as second user - should return 0 rows (not error). Verify via Dashboard > Authentication > Policies that policies are listed."
          },
          {
            "id": 4,
            "title": "Create user-files Storage Bucket with RLS Policies",
            "description": "Create a Supabase Storage bucket named 'user-files' and configure storage policies to restrict file access to the owning user based on folder path convention.",
            "dependencies": [
              1
            ],
            "details": "In Supabase Dashboard > Storage, create new bucket 'user-files' (NOT public). The folder structure will be user-files/{user_id}/* where user_id is the auth.users UUID. In SQL Editor, run storage policies: CREATE POLICY 'Users upload own files' ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'user-files' AND auth.uid()::text = (storage.foldername(name))[1]); CREATE POLICY 'Users read own files' ON storage.objects FOR SELECT USING (bucket_id = 'user-files' AND auth.uid()::text = (storage.foldername(name))[1]); CREATE POLICY 'Users delete own files' ON storage.objects FOR DELETE USING (bucket_id = 'user-files' AND auth.uid()::text = (storage.foldername(name))[1]); Save to fastapi_app/migrations/003_storage_policies.sql.",
            "status": "pending",
            "testStrategy": "Test via Supabase client or Dashboard: authenticate as user A, upload file to user-files/{user_a_id}/test.txt - should succeed. Try uploading to user-files/{user_b_id}/test.txt - should fail with 403. Test download: user A can download own files, cannot access user B's folder."
          },
          {
            "id": 5,
            "title": "Verify Schema Integrity and Document Environment Setup",
            "description": "Run comprehensive verification queries to confirm all database objects, indexes, policies, and storage bucket are correctly configured, then document the complete setup.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run verification SQL: SELECT indexname FROM pg_indexes WHERE tablename = 'usage_records' (should show idx_usage_records_user_date); SELECT tablename, policyname FROM pg_policies WHERE tablename IN ('usage_records', 'user_files'); SELECT * FROM storage.buckets WHERE name = 'user-files'. Create README section or fastapi_app/README_SUPABASE.md documenting: 1) Required env vars, 2) How to run migrations manually if needed, 3) RLS behavior explanation, 4) Storage path convention. Update project CLAUDE.md with Supabase section noting the 4 environment variables. Create .env.example in project root listing: SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, SUPABASE_JWT_SECRET.",
            "status": "pending",
            "testStrategy": "Verification queries return expected results. .env.example files exist in root and frontend-workflow/. CLAUDE.md or documentation includes Supabase setup section. New developer can follow documentation to configure their local environment successfully."
          },
          {
            "id": 6,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 13
          },
          {
            "id": 7,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 13
          }
        ]
      },
      {
        "id": 14,
        "title": "Create Backend Supabase Client and Environment Config",
        "description": "Install Supabase Python SDK, create configuration module with pydantic-settings, and establish reusable Supabase client for FastAPI backend.",
        "details": "## Implementation Steps\n\n1. **Add dependencies to requirements-base.txt**\n```\nsupabase>=2.0.0\npython-jose[cryptography]>=3.3.0\npydantic-settings>=2.0.0\n```\n\n2. **Create fastapi_app/config.py**\n```python\nfrom functools import lru_cache\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    supabase_url: str = \"\"\n    supabase_anon_key: str = \"\"\n    supabase_service_role_key: str = \"\"\n    supabase_jwt_secret: str = \"\"\n    daily_workflow_limit: int = 10\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n@lru_cache()\ndef get_settings() -> Settings:\n    return Settings()\n```\n\n3. **Create fastapi_app/supabase_client.py**\n```python\nfrom supabase import create_client, Client\nfrom fastapi_app.config import get_settings\n\n_client: Client | None = None\n_admin_client: Client | None = None\n\ndef get_supabase() -> Client:\n    \"\"\"Client respecting RLS\"\"\"\n    global _client\n    if _client is None:\n        s = get_settings()\n        _client = create_client(s.supabase_url, s.supabase_anon_key)\n    return _client\n\ndef get_supabase_admin() -> Client:\n    \"\"\"Admin client bypassing RLS\"\"\"\n    global _admin_client\n    if _admin_client is None:\n        s = get_settings()\n        _admin_client = create_client(s.supabase_url, s.supabase_service_role_key)\n    return _admin_client\n```\n\n4. **Create .env.example**\n```env\nSUPABASE_URL=https://xxx.supabase.co\nSUPABASE_ANON_KEY=eyJ...\nSUPABASE_SERVICE_ROLE_KEY=eyJ...\nSUPABASE_JWT_SECRET=your-jwt-secret\nDAILY_WORKFLOW_LIMIT=10\n```\n\n5. **Add .env to .gitignore** if not present",
        "testStrategy": "1. Unit test: get_settings() loads from .env correctly\n2. Test Supabase client can query a table: supabase.table('usage_records').select('*').limit(1).execute()\n3. Test missing env vars raise clear error\n4. Verify admin client can bypass RLS (query all users' data)",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Supabase dependencies to requirements-base.txt",
            "description": "Install required Python packages for Supabase integration, JWT handling, and configuration management by adding them to the base requirements file.",
            "dependencies": [],
            "details": "Add the following dependencies to requirements-base.txt:\n- `supabase>=2.0.0` - Official Supabase Python SDK for database/storage/auth\n- `python-jose[cryptography]>=3.3.0` - JWT token verification library\n- `pydantic-settings>=2.0.0` - Environment configuration (separate from pydantic v2+)\n\nNote: The codebase already has `pydantic` installed but `pydantic-settings` is a separate package since Pydantic v2. Place these under a new comment section `# Supabase integration` for organization.",
            "status": "pending",
            "testStrategy": "Run `pip install -r requirements-base.txt` and verify all packages install without conflicts. Check `pip show supabase pydantic-settings python-jose` shows correct versions."
          },
          {
            "id": 2,
            "title": "Create fastapi_app/config.py with pydantic-settings BaseSettings",
            "description": "Create a centralized configuration module using pydantic-settings that loads Supabase credentials and app settings from environment variables with .env file support.",
            "dependencies": [
              1
            ],
            "details": "Create `fastapi_app/config.py` implementing:\n\n1. Import from `pydantic_settings` (not `pydantic`) since they're separate packages in v2+\n2. Define `Settings(BaseSettings)` class with fields:\n   - `supabase_url: str = \"\"` - Supabase project URL\n   - `supabase_anon_key: str = \"\"` - Public anonymous key (respects RLS)\n   - `supabase_service_role_key: str = \"\"` - Admin key (bypasses RLS)\n   - `supabase_jwt_secret: str = \"\"` - For token verification\n   - `daily_workflow_limit: int = 10` - Rate limiting config\n3. Use `model_config = SettingsConfigDict(env_file=\".env\")` (v2 syntax replaces nested Config class)\n4. Implement `@lru_cache() def get_settings() -> Settings` for singleton pattern\n\nThis follows the existing pattern where `fastapi_app/utils.py` loads config from files.",
            "status": "pending",
            "testStrategy": "Unit test: Create temp .env, call get_settings(), verify values loaded correctly. Test missing env vars return defaults. Test lru_cache returns same instance."
          },
          {
            "id": 3,
            "title": "Create fastapi_app/supabase_client.py with client factory functions",
            "description": "Implement reusable Supabase client factory functions providing both RLS-respecting and admin clients for different use cases throughout the backend.",
            "dependencies": [
              2
            ],
            "details": "Create `fastapi_app/supabase_client.py` with:\n\n1. Import `create_client, Client` from supabase SDK\n2. Import `get_settings` from the config module\n3. Module-level client singletons:\n   - `_client: Client | None = None` for anon key client\n   - `_admin_client: Client | None = None` for service role client\n4. `def get_supabase() -> Client:` - Returns client using anon_key (respects RLS policies)\n5. `def get_supabase_admin() -> Client:` - Returns client using service_role_key (bypasses RLS)\n\nBoth functions use lazy initialization pattern checking if singleton is None before creating. This allows FastAPI dependencies to inject the appropriate client based on whether admin access is needed.",
            "status": "pending",
            "testStrategy": "Integration test: Call get_supabase() twice, verify same instance returned. Test client can execute `supabase.table('usage_records').select('*').limit(1).execute()`. Verify admin client can query across all users."
          },
          {
            "id": 4,
            "title": "Create .env.example template file for Supabase configuration",
            "description": "Create a documented .env.example file that developers can copy to .env, containing all required Supabase environment variables with placeholder values and helpful comments.",
            "dependencies": [],
            "details": "Create `.env.example` in project root with:\n\n```env\n# Supabase Configuration\n# Get these values from: https://supabase.com/dashboard/project/_/settings/api\nSUPABASE_URL=https://xxx.supabase.co\nSUPABASE_ANON_KEY=eyJ...\nSUPABASE_SERVICE_ROLE_KEY=eyJ...\n\n# JWT Secret for token verification\n# Found in: Project Settings > API > JWT Settings\nSUPABASE_JWT_SECRET=your-jwt-secret\n\n# Application Settings\nDAILY_WORKFLOW_LIMIT=10\n```\n\nThis file can be committed to git (unlike .env) and serves as documentation for required environment variables. Note: .env is already in .gitignore (line 151).",
            "status": "pending",
            "testStrategy": "Verify .env.example is readable and contains all variables used in config.py Settings class. Check file does NOT contain real credentials."
          },
          {
            "id": 5,
            "title": "Verify .gitignore includes .env and test full integration",
            "description": "Confirm .env is properly gitignored and perform end-to-end integration test of the complete Supabase client setup including settings loading, client creation, and basic database connectivity.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Verification steps:\n\n1. Confirm `.env` entry exists in .gitignore (already present at line 151, but verify)\n2. Create integration test or manual verification script:\n   - Copy .env.example to .env with real Supabase credentials\n   - Test: `from fastapi_app.config import get_settings; s = get_settings(); print(s.supabase_url)`\n   - Test: `from fastapi_app.supabase_client import get_supabase, get_supabase_admin`\n   - Test anon client: `get_supabase().table('usage_records').select('*').limit(1).execute()`\n   - Test admin client bypasses RLS\n3. Verify missing/empty env vars raise clear ValidationError from pydantic-settings\n4. Test that FastAPI startup doesn't fail when Supabase is not configured (graceful degradation)",
            "status": "pending",
            "testStrategy": "Run full integration test with real Supabase project. Test with missing env vars for clear error messages. Verify git status shows .env is ignored. Run pytest if test file created."
          },
          {
            "id": 6,
            "title": "Write pytest tests for Supabase client",
            "description": "Write tests in tests/test_supabase_client.py: test client initialization, test connection, test error handling",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 14
          },
          {
            "id": 7,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 14
          },
          {
            "id": 8,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 14
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Backend JWT Auth Middleware",
        "description": "Create FastAPI dependency to verify Supabase JWT tokens from Authorization header, extract user_id, and return 401 for invalid/missing tokens.",
        "details": "## Implementation Steps\n\n1. **Create fastapi_app/auth.py**\n```python\nfrom typing import Optional\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom jose import jwt, JWTError\nfrom pydantic import BaseModel\nfrom fastapi_app.config import get_settings\n\nsecurity = HTTPBearer(auto_error=False)\n\nclass CurrentUser(BaseModel):\n    user_id: str\n    email: Optional[str] = None\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security)\n) -> CurrentUser:\n    \"\"\"Verify JWT and return user context. Raises 401 if invalid.\"\"\"\n    if credentials is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Authentication required\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n    \n    try:\n        settings = get_settings()\n        payload = jwt.decode(\n            credentials.credentials,\n            settings.supabase_jwt_secret,\n            algorithms=[\"HS256\"],\n            audience=\"authenticated\"\n        )\n        user_id = payload.get(\"sub\")\n        if not user_id:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        \n        return CurrentUser(user_id=user_id, email=payload.get(\"email\"))\n    except JWTError as e:\n        raise HTTPException(status_code=401, detail=f\"Invalid token: {e}\")\n```\n\n2. **Usage example in protected endpoint**\n```python\nfrom fastapi_app.auth import get_current_user, CurrentUser\n\n@router.get(\"/protected\")\nasync def protected(user: CurrentUser = Depends(get_current_user)):\n    return {\"user_id\": user.user_id}\n```",
        "testStrategy": "1. Test endpoint returns 401 without Authorization header\n2. Test endpoint returns 401 with malformed token\n3. Test endpoint returns 401 with expired token\n4. Test endpoint returns 200 with valid Supabase token\n5. Verify user_id extracted correctly from token payload",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Settings Configuration Module with Supabase JWT Secret",
            "description": "Create fastapi_app/config.py with pydantic-settings BaseSettings to manage Supabase JWT secret and other environment variables required for authentication.",
            "dependencies": [],
            "details": "Create a new file `fastapi_app/config.py` that uses pydantic-settings to define a Settings class with:\n1. `supabase_jwt_secret: str` field to store the JWT secret (from SUPABASE_JWT_SECRET env var)\n2. `supabase_url: str` field for the Supabase project URL (from SUPABASE_URL env var)\n3. `supabase_service_key: str` optional field for admin operations\n4. Implement `get_settings()` function with `@lru_cache` decorator for singleton pattern\n5. Add `pydantic-settings>=2.0.0` to requirements-base.txt as a dependency",
            "status": "pending",
            "testStrategy": "1. Test Settings loads from environment variables correctly\n2. Test get_settings() returns singleton instance\n3. Test validation error when required env vars are missing"
          },
          {
            "id": 2,
            "title": "Add JWT Dependency Package to Requirements",
            "description": "Add python-jose[cryptography] package to requirements-base.txt for JWT token verification functionality.",
            "dependencies": [],
            "details": "Update `requirements-base.txt` to include:\n1. `python-jose[cryptography]>=3.3.0` - for JWT decoding with HS256 algorithm support\n2. This package provides the `jose.jwt` module used in the auth middleware\n3. The cryptography extra ensures proper algorithm support for Supabase JWT verification\n4. Verify the package is compatible with existing dependencies by checking no conflicts arise",
            "status": "pending",
            "testStrategy": "1. Run pip install -r requirements-base.txt successfully\n2. Verify `from jose import jwt, JWTError` imports work\n3. Test JWT decode works with sample token"
          },
          {
            "id": 3,
            "title": "Implement Auth Module with HTTPBearer Security and CurrentUser Model",
            "description": "Create fastapi_app/auth.py with HTTPBearer security scheme, CurrentUser Pydantic model, and the get_current_user dependency function.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `fastapi_app/auth.py` with:\n1. Import HTTPBearer, HTTPAuthorizationCredentials from fastapi.security\n2. Import jwt, JWTError from jose\n3. Create `security = HTTPBearer(auto_error=False)` instance\n4. Define `CurrentUser(BaseModel)` with fields: `user_id: str`, `email: Optional[str]`\n5. Implement async `get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security))` function:\n   - Return 401 with WWW-Authenticate header if credentials is None\n   - Decode JWT using settings.supabase_jwt_secret with HS256 algorithm and 'authenticated' audience\n   - Extract 'sub' claim as user_id, 'email' claim as email\n   - Return CurrentUser instance on success\n   - Return 401 with detailed error message on JWTError",
            "status": "pending",
            "testStrategy": "1. Unit test get_current_user returns 401 when credentials is None\n2. Unit test get_current_user returns 401 with malformed token\n3. Unit test get_current_user returns CurrentUser with valid token\n4. Unit test email field is optional (works with None)"
          },
          {
            "id": 4,
            "title": "Create Protected Test Endpoint to Verify Auth Middleware",
            "description": "Add a test endpoint /api/auth/me that uses the get_current_user dependency to verify the authentication middleware works correctly.",
            "dependencies": [
              3
            ],
            "details": "Create `fastapi_app/routers/auth.py` with:\n1. Create APIRouter instance\n2. Import get_current_user, CurrentUser from fastapi_app.auth\n3. Implement `GET /me` endpoint that:\n   - Takes `user: CurrentUser = Depends(get_current_user)` as dependency\n   - Returns `{\"user_id\": user.user_id, \"email\": user.email}`\n4. Update `fastapi_app/main.py` to include this router at `/api/auth` prefix\n5. This endpoint serves as both verification and a way for frontend to get current user info",
            "status": "pending",
            "testStrategy": "1. Test GET /api/auth/me returns 401 without Authorization header\n2. Test GET /api/auth/me returns 401 with invalid Bearer token\n3. Test GET /api/auth/me returns 200 with valid Supabase JWT\n4. Verify response contains correct user_id and email from token"
          },
          {
            "id": 5,
            "title": "Write Integration Tests for JWT Auth Middleware",
            "description": "Create comprehensive test suite for the JWT authentication middleware covering valid tokens, expired tokens, malformed tokens, and missing headers.",
            "dependencies": [
              4
            ],
            "details": "Create `tests/test_auth.py` with pytest tests:\n1. Import TestClient from fastapi.testclient\n2. Create fixtures for:\n   - Valid JWT token (mock signed with test secret)\n   - Expired JWT token\n   - Malformed JWT token (invalid signature)\n   - Token with missing 'sub' claim\n3. Test cases:\n   - `test_no_auth_header_returns_401`: Request without Authorization returns 401\n   - `test_malformed_token_returns_401`: Bearer with invalid format returns 401\n   - `test_expired_token_returns_401`: Expired JWT returns 401\n   - `test_invalid_signature_returns_401`: Wrong secret signature returns 401\n   - `test_missing_sub_claim_returns_401`: Token without 'sub' returns 401\n   - `test_valid_token_returns_user`: Valid token returns 200 with user data\n4. Use monkeypatch or environment variables to set test JWT secret",
            "status": "pending",
            "testStrategy": "1. Run pytest tests/test_auth.py -v and verify all tests pass\n2. Check test coverage includes all error branches\n3. Verify tests are isolated and don't require real Supabase instance"
          },
          {
            "id": 6,
            "title": "Write pytest tests for JWT middleware",
            "description": "Write tests in tests/test_auth_middleware.py: test valid token, test invalid token, test missing token, test expired token",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 7,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 15
          },
          {
            "id": 8,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 15
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Rate Limiting Service and Quota API",
        "description": "Create rate limiting service to count daily usage per user, check against 10 calls/day limit, and expose GET /api/quota endpoint returning {used, limit}.",
        "details": "## Implementation Steps\n\n1. **Create fastapi_app/services/rate_limiter.py**\n```python\nfrom datetime import date, datetime, timezone\nfrom pydantic import BaseModel\nfrom fastapi_app.supabase_client import get_supabase_admin\nfrom fastapi_app.config import get_settings\n\nclass Quota(BaseModel):\n    used: int\n    limit: int\n\nclass RateLimitService:\n    def __init__(self):\n        self.settings = get_settings()\n    \n    async def get_today_count(self, user_id: str) -> int:\n        \"\"\"Count workflow calls made today by user\"\"\"\n        supabase = get_supabase_admin()\n        today = date.today().isoformat()\n        \n        # Query usage_records where DATE(called_at) = today\n        result = supabase.table(\"usage_records\").select(\n            \"id\", count=\"exact\"\n        ).eq(\"user_id\", user_id).gte(\n            \"called_at\", f\"{today}T00:00:00Z\"\n        ).lt(\n            \"called_at\", f\"{today}T23:59:59Z\"\n        ).execute()\n        \n        return result.count or 0\n    \n    async def check_quota(self, user_id: str) -> Quota:\n        used = await self.get_today_count(user_id)\n        return Quota(used=used, limit=self.settings.daily_workflow_limit)\n    \n    async def is_limited(self, user_id: str) -> bool:\n        quota = await self.check_quota(user_id)\n        return quota.used >= quota.limit\n    \n    async def record_usage(self, user_id: str, workflow_type: str) -> None:\n        supabase = get_supabase_admin()\n        supabase.table(\"usage_records\").insert({\n            \"user_id\": user_id,\n            \"workflow_type\": workflow_type\n        }).execute()\n\nrate_limiter = RateLimitService()\n```\n\n2. **Create fastapi_app/routers/user.py**\n```python\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi_app.auth import get_current_user, CurrentUser\nfrom fastapi_app.services.rate_limiter import rate_limiter, Quota\n\nrouter = APIRouter()\n\n@router.get(\"/quota\", response_model=Quota)\nasync def get_quota(user: CurrentUser = Depends(get_current_user)):\n    \"\"\"Get remaining quota for current user\"\"\"\n    return await rate_limiter.check_quota(user.user_id)\n```\n\n3. **Mount router in main.py**\n```python\nfrom fastapi_app.routers import user\napp.include_router(user.router, prefix=\"/api\", tags=[\"user\"])\n```",
        "testStrategy": "1. Test quota returns {used: 0, limit: 10} for new user\n2. Test usage count increases after record_usage()\n3. Test is_limited() returns True when used >= 10\n4. Test daily reset (mock date to tomorrow, count should be 0)\n5. Test /api/quota returns 401 without auth",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create rate limiter service module with Quota model and RateLimitService class",
            "description": "Create fastapi_app/services/rate_limiter.py with the Quota Pydantic model and RateLimitService class containing core quota checking methods.",
            "dependencies": [],
            "details": "Create the services directory if it doesn't exist, then create rate_limiter.py with:\n1. Quota Pydantic model with 'used: int' and 'limit: int' fields\n2. RateLimitService class with __init__ that loads settings via get_settings()\n3. Import dependencies: datetime (date), pydantic BaseModel, fastapi_app.supabase_client.get_supabase_admin, fastapi_app.config.get_settings\n4. Create module-level singleton: rate_limiter = RateLimitService()\n5. Follow existing Pydantic patterns from fastapi_app/schemas.py",
            "status": "pending",
            "testStrategy": "Verify the module imports correctly without errors. Check that Quota model validates {used: 0, limit: 10} input correctly."
          },
          {
            "id": 2,
            "title": "Implement get_today_count method to query daily usage from Supabase",
            "description": "Add the get_today_count async method to RateLimitService that counts workflow calls made today by a specific user.",
            "dependencies": [
              1
            ],
            "details": "Implement get_today_count(user_id: str) -> int method:\n1. Get Supabase admin client via get_supabase_admin()\n2. Calculate today's date range: start = 'YYYY-MM-DDT00:00:00Z', end = 'YYYY-MM-DDT23:59:59Z'\n3. Query usage_records table with filters: eq('user_id', user_id), gte('called_at', start), lt('called_at', end)\n4. Use select('id', count='exact') to get count without fetching all records\n5. Return result.count or 0 if None\n6. Handle timezone properly using UTC (timezone.utc)",
            "status": "pending",
            "testStrategy": "Mock the Supabase client and verify correct date range filtering. Test with empty results (returns 0) and with multiple records (returns correct count)."
          },
          {
            "id": 3,
            "title": "Implement check_quota, is_limited, and record_usage methods",
            "description": "Complete the RateLimitService with quota checking and usage recording capabilities.",
            "dependencies": [
              2
            ],
            "details": "Add three async methods to RateLimitService:\n1. check_quota(user_id: str) -> Quota: Call get_today_count and return Quota with used count and limit from settings.daily_workflow_limit\n2. is_limited(user_id: str) -> bool: Call check_quota and return True if used >= limit\n3. record_usage(user_id: str, workflow_type: str) -> None: Insert new record into usage_records table with user_id and workflow_type fields (called_at is auto-set by Supabase default)\n4. Ensure all methods properly await async operations",
            "status": "pending",
            "testStrategy": "Test check_quota returns {used: 0, limit: 10} for new user. Test is_limited returns False when used < 10, True when used >= 10. Test record_usage increases the count by 1."
          },
          {
            "id": 4,
            "title": "Create user router with GET /api/quota endpoint",
            "description": "Create fastapi_app/routers/user.py with the quota endpoint that returns current user's usage quota.",
            "dependencies": [
              3
            ],
            "details": "Create user.py router:\n1. Import APIRouter, Depends from fastapi\n2. Import get_current_user, CurrentUser from fastapi_app.auth\n3. Import rate_limiter, Quota from fastapi_app.services.rate_limiter\n4. Create router = APIRouter()\n5. Implement @router.get('/quota', response_model=Quota) async def get_quota(user: CurrentUser = Depends(get_current_user)): return await rate_limiter.check_quota(user.user_id)\n6. Follow existing router patterns from fastapi_app/routers/paper2any.py",
            "status": "pending",
            "testStrategy": "Test endpoint returns 401 without Authorization header. Test endpoint returns 200 with valid JWT and correct quota structure {used: number, limit: 10}."
          },
          {
            "id": 5,
            "title": "Mount user router in main.py and update router __init__.py exports",
            "description": "Integrate the new user router into the FastAPI application by adding it to main.py and updating the routers package exports.",
            "dependencies": [
              4
            ],
            "details": "Modify two files:\n1. In fastapi_app/main.py: Add 'from fastapi_app.routers import user' import, then add app.include_router(user.router, prefix='/api', tags=['user']) after existing router mounts\n2. In fastapi_app/routers/__init__.py: Add 'from . import user' and update __all__ to include 'user'\n3. Ensure the /api/quota endpoint is accessible and properly documented in OpenAPI schema\n4. Follow the existing router mounting pattern used for paper2any, paper2ppt, pdf2ppt",
            "status": "pending",
            "testStrategy": "Start the FastAPI server and verify /api/quota appears in /docs. Test the full request flow: send authenticated GET request to /api/quota and verify response format {used: number, limit: number}."
          },
          {
            "id": 6,
            "title": "Write pytest tests for rate limiting",
            "description": "Write tests in tests/test_rate_limiter.py: test quota check, test limit enforcement, test daily reset logic",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 16
          },
          {
            "id": 7,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 16
          },
          {
            "id": 8,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 16
          }
        ]
      },
      {
        "id": 17,
        "title": "Implement File Management Service and API Endpoints",
        "description": "Create service to upload files to Supabase Storage, track in user_files table, and expose GET /api/files and DELETE /api/files/{id} endpoints.",
        "details": "## Implementation Steps\n\n1. **Create fastapi_app/services/file_manager.py**\n```python\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nfrom fastapi_app.supabase_client import get_supabase_admin\n\nclass UserFile(BaseModel):\n    id: str\n    file_name: str\n    file_size: Optional[int]\n    workflow_type: Optional[str]\n    created_at: str\n    download_url: Optional[str] = None\n\nclass FileManager:\n    BUCKET = \"user-files\"\n    \n    async def upload(self, user_id: str, local_path: str, workflow_type: str) -> UserFile:\n        \"\"\"Upload file to Supabase Storage and create DB record\"\"\"\n        supabase = get_supabase_admin()\n        path = Path(local_path)\n        \n        # Storage path: {user_id}/{timestamp}_{filename}\n        ts = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n        storage_path = f\"{user_id}/{ts}_{path.name}\"\n        \n        # Upload to storage\n        with open(local_path, \"rb\") as f:\n            supabase.storage.from_(self.BUCKET).upload(storage_path, f.read())\n        \n        # Insert DB record\n        record = {\n            \"user_id\": user_id,\n            \"file_path\": storage_path,\n            \"file_name\": path.name,\n            \"file_size\": path.stat().st_size,\n            \"workflow_type\": workflow_type\n        }\n        result = supabase.table(\"user_files\").insert(record).execute()\n        row = result.data[0]\n        \n        return UserFile(\n            id=row[\"id\"],\n            file_name=row[\"file_name\"],\n            file_size=row[\"file_size\"],\n            workflow_type=row[\"workflow_type\"],\n            created_at=row[\"created_at\"]\n        )\n    \n    async def list_files(self, user_id: str) -> List[UserFile]:\n        supabase = get_supabase_admin()\n        result = supabase.table(\"user_files\").select(\"*\").eq(\n            \"user_id\", user_id\n        ).order(\"created_at\", desc=True).execute()\n        \n        files = []\n        for row in result.data:\n            url = supabase.storage.from_(self.BUCKET).create_signed_url(\n                row[\"file_path\"], 3600\n            )\n            files.append(UserFile(\n                id=row[\"id\"],\n                file_name=row[\"file_name\"],\n                file_size=row[\"file_size\"],\n                workflow_type=row[\"workflow_type\"],\n                created_at=row[\"created_at\"],\n                download_url=url.get(\"signedURL\") if url else None\n            ))\n        return files\n    \n    async def delete_file(self, user_id: str, file_id: str) -> bool:\n        supabase = get_supabase_admin()\n        \n        # Get file path\n        result = supabase.table(\"user_files\").select(\"file_path\").eq(\n            \"id\", file_id\n        ).eq(\"user_id\", user_id).single().execute()\n        \n        if not result.data:\n            return False\n        \n        # Delete from storage and DB\n        supabase.storage.from_(self.BUCKET).remove([result.data[\"file_path\"]])\n        supabase.table(\"user_files\").delete().eq(\"id\", file_id).execute()\n        return True\n\nfile_manager = FileManager()\n```\n\n2. **Add endpoints to fastapi_app/routers/user.py**\n```python\nfrom fastapi_app.services.file_manager import file_manager, UserFile\nfrom typing import List\n\n@router.get(\"/files\", response_model=List[UserFile])\nasync def list_files(user: CurrentUser = Depends(get_current_user)):\n    return await file_manager.list_files(user.user_id)\n\n@router.delete(\"/files/{file_id}\")\nasync def delete_file(file_id: str, user: CurrentUser = Depends(get_current_user)):\n    success = await file_manager.delete_file(user.user_id, file_id)\n    if not success:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    return {\"success\": True}\n```",
        "testStrategy": "1. Test upload creates storage object and DB record\n2. Test list_files returns user's files with signed URLs\n3. Test delete removes from both storage and DB\n4. Test user cannot delete another user's file\n5. Test signed URL allows download within expiry",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create FileManager Pydantic Models in schemas.py",
            "description": "Add UserFile response model and any required file-related schemas to the existing fastapi_app/schemas.py file for type-safe API responses.",
            "dependencies": [],
            "details": "Add UserFile Pydantic model with fields: id (str), file_name (str), file_size (Optional[int]), workflow_type (Optional[str]), created_at (str), download_url (Optional[str]). Also add UserFileListResponse and DeleteFileResponse models. Follow existing schema patterns in the file (BaseModel inheritance, clear docstrings).",
            "status": "pending",
            "testStrategy": "Verify models can be instantiated with valid data and reject invalid data types; test JSON serialization works correctly."
          },
          {
            "id": 2,
            "title": "Create FileManager Service Module",
            "description": "Create fastapi_app/services/file_manager.py with FileManager class implementing upload, list, and delete operations using Supabase Storage and database.",
            "dependencies": [
              1
            ],
            "details": "Create fastapi_app/services/ directory and file_manager.py. Implement FileManager class with: BUCKET constant ('user-files'), async upload() method (stores file in Storage at {user_id}/{timestamp}_{filename} path, inserts record into user_files table), async list_files() method (queries user_files table, generates signed URLs via create_signed_url with 3600s expiry), async delete_file() method (removes from both Storage and DB with user ownership check). Import get_supabase_admin from fastapi_app.supabase_client (created in Task 14).",
            "status": "pending",
            "testStrategy": "Unit test each method with mocked Supabase client; test upload creates storage object and DB record; test list returns files with signed URLs; test delete removes from both storage and DB."
          },
          {
            "id": 3,
            "title": "Create User Router with File Endpoints",
            "description": "Create fastapi_app/routers/user.py with GET /files and DELETE /files/{file_id} endpoints using JWT auth dependency from Task 15.",
            "dependencies": [
              2
            ],
            "details": "Create user.py router following existing router patterns (see paper2any.py). Import get_current_user dependency from fastapi_app.auth (Task 15), import file_manager singleton. Implement: GET /files endpoint (calls file_manager.list_files with user_id from auth), DELETE /files/{file_id} endpoint (calls file_manager.delete_file, returns 404 if not found). Use response_model=List[UserFile] for list endpoint. Add proper error handling with HTTPException.",
            "status": "pending",
            "testStrategy": "Test GET /files returns 401 without auth; test DELETE /files/{id} returns 404 for non-existent file; test user cannot delete another user's file."
          },
          {
            "id": 4,
            "title": "Register User Router in main.py",
            "description": "Import and mount the user router in fastapi_app/main.py to expose /api/files and /api/files/{id} endpoints.",
            "dependencies": [
              3
            ],
            "details": "In fastapi_app/main.py, add import for user router (from fastapi_app.routers import user). Mount router with app.include_router(user.router, prefix='/api', tags=['user']). Also update fastapi_app/routers/__init__.py to export the new user module in __all__ list for consistency with existing patterns.",
            "status": "pending",
            "testStrategy": "Test /api/files and /api/files/{id} endpoints are accessible; verify /health endpoint still works; check OpenAPI docs show new endpoints."
          },
          {
            "id": 5,
            "title": "Integrate FileManager with Workflow Completion",
            "description": "Add file upload call to workflow adapters so generated files are automatically tracked in user_files when workflows complete.",
            "dependencies": [
              2,
              4
            ],
            "details": "Modify relevant workflow adapters (wa_paper2figure.py, wa_paper2ppt.py, etc.) to optionally call file_manager.upload() after workflow completion when a user_id is available in the request context. This requires passing user_id through the workflow request if authenticated. Add a helper function in file_manager.py: async def upload_workflow_output(user_id: str, output_path: str, workflow_type: str) that handles the upload logic. Consider making this opt-in via a flag to avoid breaking existing non-authenticated flows.",
            "status": "pending",
            "testStrategy": "Test workflow completion creates file record when user_id provided; test workflow still works without user_id (unauthenticated flow); verify signed URL allows download within expiry."
          },
          {
            "id": 6,
            "title": "Write pytest tests for file management",
            "description": "Write tests in tests/test_file_manager.py: test file upload, test file list, test file delete, test storage paths",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 7,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 8,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          }
        ]
      },
      {
        "id": 18,
        "title": "Integrate Auth and Rate Limiting with Workflow Endpoints",
        "description": "Update existing Paper2Any workflow endpoints (paper2figure, paper2ppt, pdf2ppt) to require authentication, check rate limits before execution, and save outputs to user storage after success.",
        "details": "## Implementation Steps\n\n1. **Create workflow dependency combining auth + rate limit**\n\nAdd to fastapi_app/auth.py:\n```python\nfrom fastapi_app.services.rate_limiter import rate_limiter\n\nasync def require_auth_and_quota(\n    user: CurrentUser = Depends(get_current_user)\n) -> CurrentUser:\n    \"\"\"Verify auth and check rate limit. Raises 429 if exceeded.\"\"\"\n    if await rate_limiter.is_limited(user.user_id):\n        raise HTTPException(\n            status_code=429,\n            detail=\"Daily limit reached (10 calls/day)\"\n        )\n    return user\n```\n\n2. **Update paper2any.py endpoint (generate_paper2figure_json)**\n\n```python\nfrom fastapi_app.auth import require_auth_and_quota, CurrentUser\nfrom fastapi_app.services.rate_limiter import rate_limiter\nfrom fastapi_app.services.file_manager import file_manager\n\n@router.post(\"/paper2figure/generate_json\", response_model=Paper2FigureResponse)\nasync def generate_paper2figure_json(\n    request: Request,\n    user: CurrentUser = Depends(require_auth_and_quota),  # NEW\n    img_gen_model_name: str = Form(...),\n    # ... rest of existing params (remove invite_code requirement)\n):\n    # ... existing workflow logic ...\n    \n    # After workflow success, record usage and save files\n    await rate_limiter.record_usage(user.user_id, \"paper2figure\")\n    \n    # Upload output files\n    if p2f_resp.ppt_filename:\n        await file_manager.upload(\n            user.user_id, \n            p2f_resp.ppt_filename, \n            \"paper2figure\"\n        )\n    \n    return Paper2FigureResponse(...)\n```\n\n3. **Similarly update other workflow endpoints:**\n   - paper2ppt.py: paper2ppt_pagecontent_json\n   - pdf2ppt.py: pdf2ppt_generate\n   - paper2video.py: paper2video_endpoint\n\n4. **Remove invite_code validation** (replaced by auth)\n   - Remove `validate_invite_code()` calls\n   - Keep invite_code as optional param for backwards compat or remove entirely\n\n5. **Update output directory structure**\n```python\ndef create_run_dir(user_id: str, task_type: str) -> Path:\n    ts = datetime.utcnow().strftime(\"%Y%m%dT%H%M%S\")\n    rid = uuid.uuid4().hex[:6]\n    # Use user_id in path for organization\n    run_dir = BASE_OUTPUT_DIR / user_id / task_type / f\"{ts}_{rid}\"\n    run_dir.mkdir(parents=True, exist_ok=True)\n    return run_dir\n```",
        "testStrategy": "1. Test workflow endpoint returns 401 without auth\n2. Test workflow endpoint returns 429 after 10 calls\n3. Test usage recorded after successful workflow\n4. Test output file uploaded to user's storage\n5. Test existing workflow functionality still works\n6. Test user can download generated file via /api/files",
        "priority": "high",
        "dependencies": [
          15,
          16,
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create combined auth+rate limit dependency in fastapi_app/auth.py",
            "description": "Add a FastAPI dependency `require_auth_and_quota` that combines user authentication with rate limit checking, returning 401 for unauthenticated users and 429 when daily quota is exceeded.",
            "dependencies": [],
            "details": "Add to fastapi_app/auth.py (which should exist from Task 15):\n\n```python\nfrom fastapi_app.services.rate_limiter import rate_limiter\n\nasync def require_auth_and_quota(\n    user: CurrentUser = Depends(get_current_user)\n) -> CurrentUser:\n    \"\"\"Verify auth and check rate limit. Raises 429 if exceeded.\"\"\"\n    if await rate_limiter.is_limited(user.user_id):\n        raise HTTPException(\n            status_code=429,\n            detail=\"Daily limit reached (10 calls/day)\"\n        )\n    return user\n```\n\nThis dependency chains auth verification first, then rate limit checking. It reuses `get_current_user` from Task 15 and `rate_limiter.is_limited()` from Task 16.",
            "status": "pending",
            "testStrategy": "Unit test: mock rate_limiter.is_limited() to return True and verify 429 is raised. Integration test: verify dependency injects user correctly when quota not exceeded."
          },
          {
            "id": 2,
            "title": "Update paper2any.py endpoints with auth, rate limiting, and file upload",
            "description": "Modify generate_paper2figure_json and generate_paper2figure endpoints to use require_auth_and_quota dependency, record usage after success, and upload outputs to user storage.",
            "dependencies": [
              1
            ],
            "details": "In fastapi_app/routers/paper2any.py:\n\n1. Add imports:\n```python\nfrom fastapi_app.auth import require_auth_and_quota, CurrentUser\nfrom fastapi_app.services.rate_limiter import rate_limiter\nfrom fastapi_app.services.file_manager import file_manager\nfrom fastapi import Depends\n```\n\n2. Update endpoint signatures to include:\n```python\nuser: CurrentUser = Depends(require_auth_and_quota)\n```\n\n3. After workflow success, add:\n```python\nawait rate_limiter.record_usage(user.user_id, \"paper2figure\")\nif p2f_resp.ppt_filename:\n    await file_manager.upload(user.user_id, p2f_resp.ppt_filename, \"paper2figure\")\n```\n\n4. Update create_run_dir to include user_id in path (see subtask 5)\n\n5. Keep invite_code as optional for backwards compat but don't validate it.",
            "status": "pending",
            "testStrategy": "Test endpoint returns 401 without Authorization header. Test endpoint returns 429 after 10 calls with same user. Test file appears in user storage after successful workflow."
          },
          {
            "id": 3,
            "title": "Update paper2ppt.py and pdf2ppt.py endpoints with auth integration",
            "description": "Apply the same auth+rate limiting pattern to paper2ppt's pagecontent_json, ppt_json, full_json endpoints and pdf2ppt's generate endpoint.",
            "dependencies": [
              1
            ],
            "details": "In fastapi_app/routers/paper2ppt.py:\n\n1. Add same imports as paper2any.py\n2. Update all 3 endpoints (pagecontent_json, ppt_json, full_json) with:\n   - Add `user: CurrentUser = Depends(require_auth_and_quota)` parameter\n   - Call `await rate_limiter.record_usage(user.user_id, \"paper2ppt\")` after success\n   - Upload output files via file_manager\n\n3. Update _create_run_dir_for_paper2ppt to use user_id instead of invite_code:\n```python\ndef _create_run_dir_for_paper2ppt(user_id: str) -> Path:\n    run_dir = PROJECT_ROOT / BASE_OUTPUT_DIR / user_id / \"paper2ppt_input\"\n```\n\nIn fastapi_app/routers/pdf2ppt.py:\n1. Same import and dependency pattern\n2. Update generate_pdf2ppt endpoint\n3. Update create_run_dir to use user_id\n4. Record usage and upload output files",
            "status": "pending",
            "testStrategy": "Test each endpoint returns 401 without auth. Test rate limiting works across all paper2ppt/* endpoints sharing the same counter. Test output files uploaded correctly."
          },
          {
            "id": 4,
            "title": "Update paper2video.py endpoint with auth integration",
            "description": "Apply auth+rate limiting pattern to the paper2video endpoint, including usage recording and output file management.",
            "dependencies": [
              1
            ],
            "details": "In fastapi_app/routers/paper2video.py:\n\n1. Add imports:\n```python\nfrom fastapi import Depends, Request\nfrom fastapi_app.auth import require_auth_and_quota, CurrentUser\nfrom fastapi_app.services.rate_limiter import rate_limiter\nfrom fastapi_app.services.file_manager import file_manager\n```\n\n2. Update endpoint signature:\n```python\n@router.post(\"/paper2video\", response_model=FeaturePaper2VideoResponse)\nasync def paper2video_endpoint(\n    body: FeaturePaper2VideoRequest,\n    user: CurrentUser = Depends(require_auth_and_quota),\n) -> FeaturePaper2VideoResponse:\n```\n\n3. After successful workflow:\n```python\nawait rate_limiter.record_usage(user.user_id, \"paper2video\")\nif resp.ppt_path:\n    await file_manager.upload(user.user_id, resp.ppt_path, \"paper2video\")\n```\n\nNote: This endpoint uses request body rather than Form, so the pattern is slightly different.",
            "status": "pending",
            "testStrategy": "Test endpoint requires authentication. Test rate limit enforcement. Test output ppt_path is uploaded to user storage. Verify workflow still functions correctly with auth overhead."
          },
          {
            "id": 5,
            "title": "Refactor output directory structure to use user_id",
            "description": "Update create_run_dir functions across all router files to organize outputs by user_id instead of invite_code, enabling per-user file management.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create a shared utility function in fastapi_app/utils.py:\n\n```python\ndef create_user_run_dir(user_id: str, task_type: str) -> Path:\n    \"\"\"Create user-specific output directory for workflow runs.\n    \n    Structure: outputs/{user_id}/{task_type}/{timestamp}_{short_uuid}/\n    \"\"\"\n    ts = datetime.utcnow().strftime(\"%Y%m%dT%H%M%S\")\n    rid = uuid.uuid4().hex[:6]\n    run_dir = BASE_OUTPUT_DIR / user_id / task_type / f\"{ts}_{rid}\"\n    (run_dir / \"input\").mkdir(parents=True, exist_ok=True)\n    (run_dir / \"output\").mkdir(parents=True, exist_ok=True)\n    return run_dir\n```\n\nUpdate each router to:\n1. Import create_user_run_dir from utils\n2. Replace calls to local create_run_dir with create_user_run_dir(user.user_id, task_type)\n3. Remove or deprecate invite_code-based directory creation\n\nThis enables file_manager to locate user outputs for the /api/files/* endpoints.",
            "status": "pending",
            "testStrategy": "Verify output directories are created under outputs/{user_id}/{task_type}/ structure. Test that multiple users' outputs are isolated. Test backward compatibility - existing outputs still accessible."
          },
          {
            "id": 6,
            "title": "Write pytest integration tests for workflow auth",
            "description": "Write tests in tests/test_workflow_integration.py: test authenticated workflow call, test rate limit on workflow, test file save after workflow",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 18
          },
          {
            "id": 7,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 18
          },
          {
            "id": 8,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 18
          }
        ]
      },
      {
        "id": 19,
        "title": "Setup Frontend Supabase Client and Auth Store",
        "description": "Install Supabase JS client in frontend-workflow, create environment config, and implement Zustand auth store with session persistence.",
        "details": "## Implementation Steps\n\n1. **Install dependencies**\n```bash\ncd frontend-workflow\nnpm install @supabase/supabase-js\n```\n\n2. **Create frontend-workflow/.env.example**\n```env\nVITE_SUPABASE_URL=https://xxx.supabase.co\nVITE_SUPABASE_ANON_KEY=eyJ...\nVITE_API_URL=http://localhost:8000\n```\n\n3. **Create src/lib/supabase.ts**\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL\nconst supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY\n\nif (!supabaseUrl || !supabaseKey) {\n  throw new Error('Missing Supabase environment variables')\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseKey, {\n  auth: {\n    autoRefreshToken: true,\n    persistSession: true\n  }\n})\n```\n\n4. **Create src/stores/authStore.ts**\n```typescript\nimport { create } from 'zustand'\nimport { User, Session } from '@supabase/supabase-js'\nimport { supabase } from '../lib/supabase'\n\ninterface Quota {\n  used: number\n  limit: number\n}\n\ninterface AuthState {\n  user: User | null\n  session: Session | null\n  loading: boolean\n  quota: Quota | null\n  \n  setUser: (user: User | null) => void\n  setSession: (session: Session | null) => void\n  setLoading: (loading: boolean) => void\n  setQuota: (quota: Quota | null) => void\n  signOut: () => Promise<void>\n  refreshQuota: () => Promise<void>\n}\n\nexport const useAuthStore = create<AuthState>((set, get) => ({\n  user: null,\n  session: null,\n  loading: true,\n  quota: null,\n  \n  setUser: (user) => set({ user }),\n  setSession: (session) => set({ session }),\n  setLoading: (loading) => set({ loading }),\n  setQuota: (quota) => set({ quota }),\n  \n  signOut: async () => {\n    await supabase.auth.signOut()\n    set({ user: null, session: null, quota: null })\n  },\n  \n  refreshQuota: async () => {\n    const { session } = get()\n    if (!session) return\n    \n    const res = await fetch(`${import.meta.env.VITE_API_URL}/api/quota`, {\n      headers: { Authorization: `Bearer ${session.access_token}` }\n    })\n    if (res.ok) {\n      set({ quota: await res.json() })\n    }\n  }\n}))\n```\n\n5. **Create src/components/AuthProvider.tsx**\n```typescript\nimport { useEffect, ReactNode } from 'react'\nimport { supabase } from '../lib/supabase'\nimport { useAuthStore } from '../stores/authStore'\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const { setUser, setSession, setLoading, refreshQuota } = useAuthStore()\n  \n  useEffect(() => {\n    supabase.auth.getSession().then(({ data: { session } }) => {\n      setSession(session)\n      setUser(session?.user ?? null)\n      setLoading(false)\n      if (session) refreshQuota()\n    })\n    \n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (event, session) => {\n        setSession(session)\n        setUser(session?.user ?? null)\n        if (event === 'SIGNED_IN') refreshQuota()\n      }\n    )\n    \n    return () => subscription.unsubscribe()\n  }, [])\n  \n  return <>{children}</>\n}\n```\n\n6. **Update src/main.tsx**\n```typescript\nimport { AuthProvider } from './components/AuthProvider'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <AuthProvider>\n      <App />\n    </AuthProvider>\n  </React.StrictMode>\n)\n```",
        "testStrategy": "1. Verify Supabase client initializes without errors\n2. Test session persists across page refresh\n3. Test onAuthStateChange fires on login/logout\n4. Test refreshQuota fetches from backend API\n5. Test signOut clears all auth state",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Supabase JS client and create environment configuration",
            "description": "Add @supabase/supabase-js dependency to package.json and create .env.example file with required environment variables for Supabase and API URL.",
            "dependencies": [],
            "details": "Run `npm install @supabase/supabase-js` in frontend-workflow directory. Create `.env.example` with VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, and VITE_API_URL placeholders. The VITE_ prefix is required for Vite to expose variables to client-side code. Also create a local `.env` file (gitignored) for development. Update .gitignore if needed to exclude .env but include .env.example.",
            "status": "pending",
            "testStrategy": "Verify package.json includes @supabase/supabase-js. Check .env.example exists with all required variables. Ensure .env is gitignored."
          },
          {
            "id": 2,
            "title": "Create Supabase client initialization module",
            "description": "Create src/lib/supabase.ts with Supabase client configuration including auto-refresh tokens and session persistence options.",
            "dependencies": [
              1
            ],
            "details": "Create new directory `src/lib/` and add `supabase.ts`. Initialize createClient with VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY from import.meta.env. Configure auth options: autoRefreshToken=true, persistSession=true. Include runtime check that throws descriptive error if env vars are missing. Export the configured supabase client instance for use throughout the app.",
            "status": "pending",
            "testStrategy": "Import supabase client in a test component and verify it initializes without errors. Check browser console for any Supabase connection warnings."
          },
          {
            "id": 3,
            "title": "Implement Zustand auth store with session and quota management",
            "description": "Create src/stores/authStore.ts implementing the AuthState interface with user, session, loading, quota state and methods for signOut and refreshQuota.",
            "dependencies": [
              2
            ],
            "details": "Create `src/stores/` directory and `authStore.ts`. Define AuthState interface with: user (User|null), session (Session|null), loading (boolean), quota (Quota|null with used/limit numbers). Implement zustand store with create() including setters for all state, signOut() that calls supabase.auth.signOut() and clears state, and refreshQuota() that fetches from VITE_API_URL/api/quota with Bearer token authorization header. Use zustand's get() to access current session in refreshQuota.",
            "status": "pending",
            "testStrategy": "Test store actions in React DevTools or by creating a simple test component. Verify setUser/setSession update state correctly. Test signOut clears all auth-related state."
          },
          {
            "id": 4,
            "title": "Create AuthProvider component with session lifecycle management",
            "description": "Implement src/components/AuthProvider.tsx that initializes auth state on mount and subscribes to Supabase auth state changes.",
            "dependencies": [
              3
            ],
            "details": "Create AuthProvider as a React functional component accepting children prop. In useEffect on mount: call supabase.auth.getSession() to restore session, update store with setSession/setUser/setLoading(false), and call refreshQuota if session exists. Subscribe to supabase.auth.onAuthStateChange to handle SIGNED_IN/SIGNED_OUT events, updating store and refreshing quota on sign in. Return cleanup function that calls subscription.unsubscribe(). Render children wrapped in fragment.",
            "status": "pending",
            "testStrategy": "Verify session persists across page refresh by checking auth store state in React DevTools. Test that onAuthStateChange fires correctly by logging in/out and observing store updates."
          },
          {
            "id": 5,
            "title": "Integrate AuthProvider into main.tsx application entry point",
            "description": "Update src/main.tsx to wrap the App component with AuthProvider to enable authentication context throughout the application.",
            "dependencies": [
              4
            ],
            "details": "Import AuthProvider from './components/AuthProvider'. Modify the ReactDOM.createRoot render to wrap <App /> inside <AuthProvider>. Maintain existing React.StrictMode wrapper. The final structure should be: StrictMode > AuthProvider > App. This ensures auth state is available to all components in the tree before any protected routes or user-specific content renders.",
            "status": "pending",
            "testStrategy": "Start dev server and verify app loads without errors. Check React DevTools component tree shows AuthProvider wrapping App. Verify auth store loading state transitions from true to false on initial load."
          },
          {
            "id": 6,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 19
          },
          {
            "id": 7,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 19
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Frontend Login and Register Pages",
        "description": "Create email/password login and registration forms using Supabase client directly (signInWithPassword, signUp). No OAuth in v1.",
        "details": "## Implementation Steps\n\n1. **Create src/components/auth/LoginPage.tsx**\n```typescript\nimport { useState } from 'react'\nimport { supabase } from '../../lib/supabase'\nimport { Mail, Lock, AlertCircle } from 'lucide-react'\n\ninterface Props {\n  onSwitchToRegister: () => void\n}\n\nexport function LoginPage({ onSwitchToRegister }: Props) {\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  \n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setLoading(true)\n    setError(null)\n    \n    const { error } = await supabase.auth.signInWithPassword({ email, password })\n    if (error) setError(error.message)\n    setLoading(false)\n  }\n  \n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-[#0a0a1a]\">\n      <div className=\"glass-dark p-8 rounded-xl w-full max-w-md border border-white/10\">\n        <h2 className=\"text-2xl font-bold text-white mb-6 text-center\">\n          Sign in to DataFlow Agent\n        </h2>\n        \n        {error && (\n          <div className=\"mb-4 p-3 bg-red-500/20 border border-red-500/50 rounded-lg flex items-center gap-2 text-red-300\">\n            <AlertCircle size={18} />\n            <span className=\"text-sm\">{error}</span>\n          </div>\n        )}\n        \n        <form onSubmit={handleLogin} className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm text-gray-400 mb-1\">Email</label>\n            <div className=\"relative\">\n              <Mail className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-500\" size={18} />\n              <input\n                type=\"email\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                className=\"w-full pl-10 pr-4 py-2 bg-white/5 border border-white/10 rounded-lg text-white\"\n                placeholder=\"you@example.com\"\n                required\n              />\n            </div>\n          </div>\n          \n          <div>\n            <label className=\"block text-sm text-gray-400 mb-1\">Password</label>\n            <div className=\"relative\">\n              <Lock className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-500\" size={18} />\n              <input\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                className=\"w-full pl-10 pr-4 py-2 bg-white/5 border border-white/10 rounded-lg text-white\"\n                placeholder=\"password\"\n                required\n              />\n            </div>\n          </div>\n          \n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"w-full py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg disabled:opacity-50\"\n          >\n            {loading ? 'Signing in...' : 'Sign in'}\n          </button>\n        </form>\n        \n        <p className=\"mt-6 text-center text-gray-400 text-sm\">\n          No account? <button onClick={onSwitchToRegister} className=\"text-primary-400 hover:underline\">Sign up</button>\n        </p>\n      </div>\n    </div>\n  )\n}\n```\n\n2. **Create src/components/auth/RegisterPage.tsx**\n```typescript\nimport { useState } from 'react'\nimport { supabase } from '../../lib/supabase'\nimport { Mail, Lock, AlertCircle, CheckCircle } from 'lucide-react'\n\ninterface Props {\n  onSwitchToLogin: () => void\n}\n\nexport function RegisterPage({ onSwitchToLogin }: Props) {\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [confirmPassword, setConfirmPassword] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [success, setSuccess] = useState(false)\n  \n  const handleRegister = async (e: React.FormEvent) => {\n    e.preventDefault()\n    if (password !== confirmPassword) {\n      setError('Passwords do not match')\n      return\n    }\n    if (password.length < 6) {\n      setError('Password must be at least 6 characters')\n      return\n    }\n    \n    setLoading(true)\n    setError(null)\n    \n    const { error } = await supabase.auth.signUp({ email, password })\n    if (error) {\n      setError(error.message)\n    } else {\n      setSuccess(true)\n    }\n    setLoading(false)\n  }\n  \n  if (success) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-[#0a0a1a]\">\n        <div className=\"glass-dark p-8 rounded-xl w-full max-w-md border border-white/10 text-center\">\n          <CheckCircle className=\"mx-auto text-green-500 mb-4\" size={48} />\n          <h2 className=\"text-xl font-bold text-white mb-2\">Check your email</h2>\n          <p className=\"text-gray-400 mb-4\">Verification link sent to {email}</p>\n          <button onClick={onSwitchToLogin} className=\"text-primary-400 hover:underline\">\n            Back to login\n          </button>\n        </div>\n      </div>\n    )\n  }\n  \n  // Similar form structure as LoginPage with confirm password field\n  // ...\n}\n```",
        "testStrategy": "1. Test login with valid credentials succeeds\n2. Test login with invalid credentials shows error\n3. Test register creates account and shows confirmation\n4. Test password confirmation validation\n5. Test loading states display correctly\n6. Visual test: Forms match existing app style",
        "priority": "high",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Supabase client initialization file",
            "description": "Set up src/lib/supabase.ts with createClient configuration using environment variables for SUPABASE_URL and SUPABASE_ANON_KEY",
            "dependencies": [],
            "details": "Create a new src/lib/supabase.ts file that initializes the Supabase client using @supabase/supabase-js. Configure it to read VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY from environment variables via import.meta.env. Export the supabase client instance for use across the application. This is a prerequisite for all auth operations.",
            "status": "pending",
            "testStrategy": "Verify the supabase client can be imported and has auth methods available. Check that environment variables are correctly read from .env file."
          },
          {
            "id": 2,
            "title": "Create Zustand auth store for user state management",
            "description": "Implement src/stores/authStore.ts using zustand to manage user authentication state, loading state, and auth session listener",
            "dependencies": [
              1
            ],
            "details": "Create a zustand store that tracks: user (User | null), session (Session | null), loading (boolean). Implement init() function that calls supabase.auth.getSession() and sets up onAuthStateChange listener. Export useAuthStore hook. The store should automatically sync with Supabase auth state changes (login, logout, token refresh).",
            "status": "pending",
            "testStrategy": "Test that store initializes with loading=true, updates user state on auth changes, and properly handles logout by clearing user state."
          },
          {
            "id": 3,
            "title": "Implement LoginPage component with email/password form",
            "description": "Create src/components/auth/LoginPage.tsx with email/password inputs, error handling, loading states, and supabase.auth.signInWithPassword integration",
            "dependencies": [
              1,
              2
            ],
            "details": "Build a login form component matching the existing glass-dark design system. Include: email input with Mail icon, password input with Lock icon, submit button with loading spinner, error display with AlertCircle icon. Use supabase.auth.signInWithPassword() for authentication. Provide onSwitchToRegister callback prop to toggle between login/register views. Style using existing primary-500, glass-dark, and border-white/10 patterns.",
            "status": "pending",
            "testStrategy": "Test login with valid credentials succeeds and updates auth store. Test invalid credentials show error message. Test loading state displays during API call. Visual test: form matches existing app style."
          },
          {
            "id": 4,
            "title": "Implement RegisterPage component with email/password/confirm form",
            "description": "Create src/components/auth/RegisterPage.tsx with registration form including password confirmation, client-side validation, and supabase.auth.signUp integration",
            "dependencies": [
              1,
              2
            ],
            "details": "Build a registration form with: email input, password input, confirm password input, submit button. Implement client-side validation: passwords must match, password minimum 6 characters. Use supabase.auth.signUp() for registration. Show success state with CheckCircle icon and 'Check your email' message after successful signup. Include onSwitchToLogin callback prop. Match existing design patterns from the codebase.",
            "status": "pending",
            "testStrategy": "Test register creates account and shows confirmation. Test password mismatch shows validation error. Test password < 6 chars shows validation error. Test loading states display correctly."
          },
          {
            "id": 5,
            "title": "Initialize auth store in main.tsx and add @supabase/supabase-js dependency",
            "description": "Add @supabase/supabase-js to package.json dependencies and call authStore.init() in main.tsx to set up auth listener on app startup",
            "dependencies": [
              1,
              2
            ],
            "details": "First add @supabase/supabase-js as a dependency in package.json. Then modify main.tsx to import the auth store and call the init() function before rendering the app, ensuring auth state is initialized on page load. This enables persistent sessions - when users refresh the page, their auth state is restored from Supabase's session storage. Add a .env.example file documenting required VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY variables.",
            "status": "pending",
            "testStrategy": "Test that auth session persists across page refresh. Test that logged-in users remain logged in after refresh. Test that app renders correctly with auth store initialized."
          },
          {
            "id": 6,
            "title": "UI Design Review - Analyze existing UI patterns and design Login/Register pages",
            "description": "Review frontend-workflow/src components for existing patterns. Design login/register UI mockup considering current styling, layout conventions, and user flow.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 20
          },
          {
            "id": 7,
            "title": "Puppeteer E2E Test - Test Login/Register flow",
            "description": "Use Puppeteer MCP to test: 1) Navigate to login page 2) Fill form and submit 3) Verify redirect after login 4) Test registration flow 5) Test error states",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 20
          },
          {
            "id": 8,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 20
          },
          {
            "id": 9,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 20
          },
          {
            "id": 10,
            "title": "PM Review - UX feedback on Login/Register",
            "description": "Present Login/Register UI to PM for UX review. Document feedback on: user flow, error messages, form validation UX, visual design. Create list of improvements for next task.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 20
          }
        ]
      },
      {
        "id": 21,
        "title": "Implement Protected Routes and Quota Display",
        "description": "Create ProtectedRoute component to redirect unauthenticated users to login, add quota display in header showing ': X/10', and disable workflow buttons when quota = 0.",
        "details": "## Implementation Steps\n\n1. **Create src/components/auth/ProtectedRoute.tsx**\n```typescript\nimport { ReactNode, useState } from 'react'\nimport { useAuthStore } from '../../stores/authStore'\nimport { LoginPage } from './LoginPage'\nimport { RegisterPage } from './RegisterPage'\n\nexport function ProtectedRoute({ children }: { children: ReactNode }) {\n  const { user, loading } = useAuthStore()\n  const [mode, setMode] = useState<'login' | 'register'>('login')\n  \n  if (loading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-[#0a0a1a]\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary-500\" />\n      </div>\n    )\n  }\n  \n  if (!user) {\n    return mode === 'login' \n      ? <LoginPage onSwitchToRegister={() => setMode('register')} />\n      : <RegisterPage onSwitchToLogin={() => setMode('login')} />\n  }\n  \n  return <>{children}</>\n}\n```\n\n2. **Create src/components/QuotaDisplay.tsx**\n```typescript\nimport { useEffect } from 'react'\nimport { useAuthStore } from '../stores/authStore'\nimport { Zap, AlertTriangle } from 'lucide-react'\n\nexport function QuotaDisplay() {\n  const { quota, refreshQuota, user } = useAuthStore()\n  \n  useEffect(() => {\n    if (user) {\n      refreshQuota()\n      const interval = setInterval(refreshQuota, 60000) // Refresh every minute\n      return () => clearInterval(interval)\n    }\n  }, [user])\n  \n  if (!quota) return null\n  \n  const remaining = quota.limit - quota.used\n  const isLow = remaining <= 2\n  \n  return (\n    <div className={`flex items-center gap-2 px-3 py-1.5 rounded-lg ${\n      remaining === 0 ? 'bg-red-500/20' : isLow ? 'bg-yellow-500/20' : 'bg-white/5'\n    } border border-white/10`}>\n      {remaining === 0 || isLow ? (\n        <AlertTriangle size={16} className={remaining === 0 ? 'text-red-400' : 'text-yellow-400'} />\n      ) : (\n        <Zap size={16} className=\"text-primary-400\" />\n      )}\n      <span className={`text-sm ${\n        remaining === 0 ? 'text-red-300' : isLow ? 'text-yellow-300' : 'text-gray-300'\n      }`}>\n        : {remaining}/{quota.limit}\n      </span>\n    </div>\n  )\n}\n```\n\n3. **Create src/components/UserMenu.tsx**\n```typescript\nimport { useState, useRef, useEffect } from 'react'\nimport { useAuthStore } from '../stores/authStore'\nimport { User, LogOut } from 'lucide-react'\n\nexport function UserMenu() {\n  const { user, signOut } = useAuthStore()\n  const [open, setOpen] = useState(false)\n  const ref = useRef<HTMLDivElement>(null)\n  \n  // Close on outside click\n  useEffect(() => {\n    const handler = (e: MouseEvent) => {\n      if (ref.current && !ref.current.contains(e.target as Node)) setOpen(false)\n    }\n    document.addEventListener('mousedown', handler)\n    return () => document.removeEventListener('mousedown', handler)\n  }, [])\n  \n  if (!user) return null\n  \n  return (\n    <div ref={ref} className=\"relative\">\n      <button\n        onClick={() => setOpen(!open)}\n        className=\"flex items-center gap-2 px-3 py-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10\"\n      >\n        <User size={18} className=\"text-gray-400\" />\n        <span className=\"text-sm text-gray-300 max-w-[100px] truncate\">{user.email}</span>\n      </button>\n      \n      {open && (\n        <div className=\"absolute right-0 mt-2 w-40 glass-dark rounded-lg border border-white/10 shadow-xl z-50 p-2\">\n          <button\n            onClick={signOut}\n            className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-red-400 hover:bg-red-500/10 rounded-lg\"\n          >\n            <LogOut size={16} /> Sign out\n          </button>\n        </div>\n      )}\n    </div>\n  )\n}\n```\n\n4. **Update App.tsx**\n```typescript\nimport { ProtectedRoute } from './components/auth/ProtectedRoute'\nimport { QuotaDisplay } from './components/QuotaDisplay'\nimport { UserMenu } from './components/UserMenu'\n\nfunction App() {\n  return (\n    <ProtectedRoute>\n      {/* ... existing layout ... */}\n      <header>\n        {/* ... existing header content ... */}\n        <div className=\"flex items-center gap-4\">\n          {/* page tabs */}\n          <QuotaDisplay />\n          <UserMenu />\n        </div>\n      </header>\n      {/* ... */}\n    </ProtectedRoute>\n  )\n}\n```\n\n5. **Disable workflow button when quota = 0**\n\nIn workflow page components (Paper2GraphPage.tsx, etc.):\n```typescript\nconst { quota } = useAuthStore()\nconst canExecute = quota && (quota.limit - quota.used) > 0\n\n<button disabled={!canExecute}>\n  {canExecute ? 'Execute' : 'Limit Reached'}\n</button>\n```",
        "testStrategy": "1. Test unauthenticated user sees login page\n2. Test authenticated user sees main app\n3. Test quota display shows correct values\n4. Test warning style when quota low (<= 2)\n5. Test workflow button disabled when quota = 0\n6. Test user menu shows and sign out works",
        "priority": "high",
        "dependencies": [
          19,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create authStore with Zustand for user session and quota management",
            "description": "Implement the Zustand store (src/stores/authStore.ts) that manages user authentication state, session persistence, and quota information. This store will integrate with the Supabase client created in Task 19 dependencies.",
            "dependencies": [],
            "details": "Create src/stores/authStore.ts with the following structure:\n\n1. Define state interface with: user (Supabase User | null), session (Session | null), quota ({used: number, limit: number} | null), loading (boolean)\n\n2. Define actions: signIn(email, password), signUp(email, password), signOut(), refreshQuota(), initialize()\n\n3. In initialize(), subscribe to supabase.auth.onAuthStateChange to automatically update user/session state\n\n4. In refreshQuota(), fetch from /api/quota endpoint with Bearer token authorization header\n\n5. Export useAuthStore hook for component usage\n\nKey patterns to follow from existing codebase:\n- Use Zustand's create() with immer-style updates\n- Match the existing dark theme UI feedback patterns seen in Paper2GraphPage.tsx for loading states\n- Store structure should be at src/stores/authStore.ts (new directory needed)",
            "status": "pending",
            "testStrategy": "1. Verify store initializes with loading=true, then sets user from session\n2. Test signIn updates user state correctly\n3. Test signOut clears user and quota state\n4. Test refreshQuota fetches and updates quota values\n5. Verify onAuthStateChange listener updates state on session changes"
          },
          {
            "id": 2,
            "title": "Create ProtectedRoute component with login/register toggle",
            "description": "Build the ProtectedRoute wrapper component that displays LoginPage or RegisterPage for unauthenticated users, shows a loading spinner during auth check, and renders children for authenticated users.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/auth/ProtectedRoute.tsx:\n\n1. Import useAuthStore and access { user, loading }\n\n2. Maintain local state for mode ('login' | 'register') to toggle between pages\n\n3. Render loading state: Use the existing glass-dark spinner pattern from App.tsx (animate-spin rounded-full border-t-2 border-primary-500)\n\n4. Render unauthenticated state: Show LoginPage with onSwitchToRegister callback, or RegisterPage with onSwitchToLogin callback based on mode\n\n5. Render authenticated state: Simply return <>{children}</>\n\n6. Match the dark bg-[#0a0a1a] background color used in App.tsx\n\nFile structure:\n- src/components/auth/ProtectedRoute.tsx\n- src/components/auth/LoginPage.tsx (from Task 20)\n- src/components/auth/RegisterPage.tsx (from Task 20)",
            "status": "pending",
            "testStrategy": "1. Test unauthenticated user sees LoginPage by default\n2. Test clicking 'register' link switches to RegisterPage\n3. Test clicking 'login' link on RegisterPage switches back\n4. Test loading spinner shows when loading=true\n5. Test authenticated user sees children content\n6. Test page redirects work after successful login"
          },
          {
            "id": 3,
            "title": "Create QuotaDisplay component showing ': X/10' in header",
            "description": "Implement the QuotaDisplay component that shows remaining quota with visual indicators for normal, low (2), and exhausted (0) states. Include auto-refresh every 60 seconds.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/QuotaDisplay.tsx:\n\n1. Import useAuthStore and access { quota, refreshQuota, user }\n\n2. Use useEffect to call refreshQuota() when user is available, set up 60-second interval refresh, clean up on unmount\n\n3. Return null if quota is null (not loaded yet)\n\n4. Calculate remaining = quota.limit - quota.used\n\n5. Apply visual states:\n   - Normal (remaining > 2): bg-white/5 border-white/10, Zap icon text-primary-400, text-gray-300\n   - Low (remaining  2): bg-yellow-500/20, AlertTriangle icon text-yellow-400, text-yellow-300\n   - Exhausted (remaining === 0): bg-red-500/20, AlertTriangle icon text-red-400, text-red-300\n\n6. Display format: ': {remaining}/{limit}'\n\n7. Use existing glass styling patterns from App.tsx: px-3 py-1.5 rounded-lg border border-white/10\n\n8. Import icons from lucide-react (Zap, AlertTriangle) matching existing icon usage",
            "status": "pending",
            "testStrategy": "1. Test displays ': 10/10' for new user with full quota\n2. Test yellow warning styling when quota  2\n3. Test red exhausted styling when quota = 0\n4. Test component returns null before quota loads\n5. Test auto-refresh interval triggers every 60 seconds\n6. Test refresh on user change"
          },
          {
            "id": 4,
            "title": "Create UserMenu dropdown component with sign out",
            "description": "Build the UserMenu dropdown showing user email with a sign out option. Include click-outside-to-close behavior using ref and event listeners.",
            "dependencies": [
              1
            ],
            "details": "Create src/components/UserMenu.tsx:\n\n1. Import useAuthStore and access { user, signOut }\n\n2. Use useState for open (boolean) dropdown state\n\n3. Use useRef<HTMLDivElement> and useEffect for click-outside detection:\n   - Add mousedown listener on document\n   - Check if click target is outside ref.current\n   - Close dropdown if outside click\n   - Clean up listener on unmount\n\n4. Return null if !user\n\n5. Render button with:\n   - User icon from lucide-react\n   - Truncated email (max-w-[100px] truncate)\n   - Styling: px-3 py-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10\n\n6. Render dropdown when open:\n   - Position: absolute right-0 mt-2 w-40\n   - Styling: glass-dark rounded-lg border border-white/10 shadow-xl z-50 p-2\n   - Sign out button: flex items-center gap-2 px-3 py-2 text-sm text-red-400 hover:bg-red-500/10 rounded-lg\n   - LogOut icon from lucide-react",
            "status": "pending",
            "testStrategy": "1. Test component returns null when no user\n2. Test clicking button toggles dropdown open/closed\n3. Test clicking outside closes dropdown\n4. Test sign out button calls signOut and closes dropdown\n5. Test user email displays truncated properly\n6. Test dropdown z-index overlays content correctly"
          },
          {
            "id": 5,
            "title": "Integrate ProtectedRoute, QuotaDisplay, UserMenu in App.tsx and disable workflow buttons when quota=0",
            "description": "Update App.tsx to wrap content with ProtectedRoute, add QuotaDisplay and UserMenu to header, and modify workflow pages to disable execute buttons when quota is exhausted.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update src/App.tsx:\n\n1. Import ProtectedRoute, QuotaDisplay, UserMenu components\n\n2. Wrap entire return JSX with <ProtectedRoute>...</ProtectedRoute>\n\n3. In header div (line 34 area with page tabs), add after the tab buttons:\n   - <QuotaDisplay />\n   - <UserMenu />\n   - Wrap these in a flex container with gap-4\n\n4. Reorganize header layout to fit new components:\n   - Left: Logo section (existing)\n   - Center: Page tabs (existing)\n   - Right: QuotaDisplay + UserMenu (new)\n\nUpdate workflow page components (Paper2GraphPage.tsx, Paper2PptPage.tsx, Pdf2PptPage.tsx, Ppt2PolishPage.tsx):\n\n1. Import useAuthStore at top of each file\n\n2. In component body, add: const { quota } = useAuthStore()\n\n3. Add computed variable: const canExecute = quota && (quota.limit - quota.used) > 0\n\n4. Find the main generate/submit button and add:\n   - disabled={!canExecute || isLoading}\n   - Conditional button text: {canExecute ? 'Generate...' : 'Limit Reached'}\n   - Add disabled styling: disabled:opacity-50 disabled:cursor-not-allowed",
            "status": "pending",
            "testStrategy": "1. Test unauthenticated user sees login page instead of app\n2. Test authenticated user sees main app with QuotaDisplay and UserMenu in header\n3. Test quota display shows correct values in header\n4. Test workflow button is clickable when quota > 0\n5. Test workflow button is disabled and shows 'Limit Reached' when quota = 0\n6. Test user menu appears and sign out works\n7. Test after sign out, login page appears again"
          },
          {
            "id": 6,
            "title": "UI Design Review - Design Protected Routes and Quota Display",
            "description": "Review existing header/navigation patterns. Design quota display component placement and styling. Plan protected route UX flow.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 7,
            "title": "Puppeteer E2E Test - Test Protected Routes and Quota",
            "description": "Use Puppeteer MCP to test: 1) Unauthenticated redirect to login 2) Authenticated access to protected pages 3) Quota display shows correct values",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 8,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 9,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 10,
            "title": "Implement PM Feedback from Login/Register review",
            "description": "Address UX issues identified in PM review of Login/Register. Update error messages, adjust user flow, improve visual feedback as recommended.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 11,
            "title": "PM Review - UX feedback on Protected Routes and Quota",
            "description": "Present Protected Routes and Quota UI to PM for UX review. Document feedback on: quota display clarity, navigation flow, auth state indicators.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 21
          }
        ]
      },
      {
        "id": 22,
        "title": "Implement Frontend File List Page",
        "description": "Create simple file list component showing user's generated files in a table with columns: filename, size, date, download button, and delete button.",
        "details": "## Implementation Steps\n\n1. **Create src/lib/api.ts**\n```typescript\nimport { supabase } from './supabase'\n\nconst API_URL = import.meta.env.VITE_API_URL\n\nasync function authHeaders(): Promise<HeadersInit> {\n  const { data: { session } } = await supabase.auth.getSession()\n  return {\n    'Authorization': `Bearer ${session?.access_token}`,\n    'Content-Type': 'application/json'\n  }\n}\n\nexport interface UserFile {\n  id: string\n  file_name: string\n  file_size: number | null\n  workflow_type: string | null\n  created_at: string\n  download_url: string | null\n}\n\nexport const api = {\n  async getFiles(): Promise<UserFile[]> {\n    const res = await fetch(`${API_URL}/api/files`, { headers: await authHeaders() })\n    if (!res.ok) throw new Error('Failed to fetch files')\n    return res.json()\n  },\n  \n  async deleteFile(id: string): Promise<void> {\n    const res = await fetch(`${API_URL}/api/files/${id}`, {\n      method: 'DELETE',\n      headers: await authHeaders()\n    })\n    if (!res.ok) throw new Error('Failed to delete file')\n  }\n}\n```\n\n2. **Create src/components/FilesPage.tsx**\n```typescript\nimport { useState, useEffect } from 'react'\nimport { api, UserFile } from '../lib/api'\nimport { FileText, Download, Trash2, RefreshCw } from 'lucide-react'\n\nfunction formatSize(bytes: number | null): string {\n  if (!bytes) return '-'\n  if (bytes < 1024) return `${bytes} B`\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`\n}\n\nfunction formatDate(dateStr: string): string {\n  return new Date(dateStr).toLocaleDateString('zh-CN', {\n    month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'\n  })\n}\n\nexport function FilesPage() {\n  const [files, setFiles] = useState<UserFile[]>([])\n  const [loading, setLoading] = useState(true)\n  \n  const loadFiles = async () => {\n    setLoading(true)\n    try {\n      setFiles(await api.getFiles())\n    } catch (e) {\n      console.error(e)\n    }\n    setLoading(false)\n  }\n  \n  useEffect(() => { loadFiles() }, [])\n  \n  const handleDelete = async (id: string) => {\n    if (!confirm('Delete this file?')) return\n    try {\n      await api.deleteFile(id)\n      setFiles(files.filter(f => f.id !== id))\n    } catch (e) {\n      alert('Failed to delete')\n    }\n  }\n  \n  return (\n    <div className=\"p-6\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <h1 className=\"text-xl font-bold text-white\">My Files</h1>\n        <button onClick={loadFiles} className=\"p-2 hover:bg-white/10 rounded-lg\">\n          <RefreshCw size={18} className=\"text-gray-400\" />\n        </button>\n      </div>\n      \n      {loading ? (\n        <div className=\"text-center py-12\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-t-2 border-primary-500 mx-auto\" />\n        </div>\n      ) : files.length === 0 ? (\n        <div className=\"text-center py-12\">\n          <FileText className=\"mx-auto text-gray-600 mb-4\" size={48} />\n          <p className=\"text-gray-400\">No files yet</p>\n        </div>\n      ) : (\n        <table className=\"w-full\">\n          <thead>\n            <tr className=\"text-left text-sm text-gray-500 border-b border-white/10\">\n              <th className=\"pb-3\">File</th>\n              <th className=\"pb-3\">Size</th>\n              <th className=\"pb-3\">Date</th>\n              <th className=\"pb-3\">Type</th>\n              <th className=\"pb-3\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {files.map(file => (\n              <tr key={file.id} className=\"border-b border-white/5 hover:bg-white/5\">\n                <td className=\"py-3 text-white\">{file.file_name}</td>\n                <td className=\"py-3 text-gray-400 text-sm\">{formatSize(file.file_size)}</td>\n                <td className=\"py-3 text-gray-400 text-sm\">{formatDate(file.created_at)}</td>\n                <td className=\"py-3 text-gray-400 text-sm\">{file.workflow_type || '-'}</td>\n                <td className=\"py-3\">\n                  <div className=\"flex items-center gap-2\">\n                    {file.download_url && (\n                      <a href={file.download_url} target=\"_blank\" className=\"p-1.5 hover:bg-white/10 rounded text-primary-400\">\n                        <Download size={16} />\n                      </a>\n                    )}\n                    <button onClick={() => handleDelete(file.id)} className=\"p-1.5 hover:bg-red-500/10 rounded text-red-400\">\n                      <Trash2 size={16} />\n                    </button>\n                  </div>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n    </div>\n  )\n}\n```\n\n3. **Add Files page to App navigation**\n\nUpdate App.tsx to add 'files' page:\n```typescript\nconst [activePage, setActivePage] = useState<'paper2figure' | 'paper2ppt' | 'pdf2ppt' | 'ppt2polish' | 'files'>('paper2figure')\n\n// Add tab button\n<button onClick={() => setActivePage('files')} className={...}>My Files</button>\n\n// Add page content\n{activePage === 'files' && <FilesPage />}\n```",
        "testStrategy": "1. Test file list loads and displays correctly\n2. Test download button opens file in new tab\n3. Test delete shows confirmation and removes file\n4. Test empty state when no files\n5. Test refresh button reloads list\n6. Test loading state displays",
        "priority": "medium",
        "dependencies": [
          19,
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API client module with Supabase authentication helpers",
            "description": "Create src/lib/api.ts with authenticated fetch wrapper using Supabase JWT tokens, UserFile interface, and api object with getFiles/deleteFile methods.",
            "dependencies": [],
            "details": "Create new directory src/lib/ and implement api.ts with: (1) Import supabase from './supabase' (assumes Task 19 creates this), (2) authHeaders() async function to get session and return Authorization header, (3) UserFile interface with id, file_name, file_size, workflow_type, created_at, download_url fields, (4) api.getFiles() to GET /api/files, (5) api.deleteFile(id) to DELETE /api/files/:id. Use VITE_API_URL env variable. Handle error responses properly.",
            "status": "pending",
            "testStrategy": "Test that authHeaders returns valid Authorization header when logged in, returns error when not. Test getFiles returns array, deleteFile calls correct endpoint with DELETE method."
          },
          {
            "id": 2,
            "title": "Create FilesPage component with table structure and empty state",
            "description": "Create src/components/FilesPage.tsx with file list table layout, column headers (File, Size, Date, Type, Actions), and empty state UI when no files exist.",
            "dependencies": [
              1
            ],
            "details": "Create FilesPage.tsx functional component with: (1) useState for files array and loading state, (2) useEffect to call loadFiles on mount, (3) Table structure matching existing glass styling from Paper2PptPage, (4) Columns: filename, size with formatSize helper, date with formatDate helper, workflow_type, action buttons, (5) Empty state with FileText icon and 'No files yet' message, (6) Loading spinner during fetch. Use lucide-react icons (FileText, Download, Trash2, RefreshCw). Follow existing component patterns.",
            "status": "pending",
            "testStrategy": "Test empty state renders when files array empty. Test loading spinner shows during loading=true. Test table headers render correctly. Visual test matches existing app styling."
          },
          {
            "id": 3,
            "title": "Implement file download and delete functionality with confirmation",
            "description": "Add download button that opens file URL in new tab, and delete button with confirmation dialog that calls API and removes file from state.",
            "dependencies": [
              2
            ],
            "details": "In FilesPage.tsx: (1) handleDelete(id) function with window.confirm('Delete this file?'), (2) On confirm, call api.deleteFile(id), (3) On success, filter out deleted file from files state using setFiles(files.filter(f => f.id !== id)), (4) On error, show alert('Failed to delete'), (5) Download button as <a> tag with href={file.download_url} and target='_blank', (6) Style buttons with hover states matching existing patterns (p-1.5, hover:bg-white/10, rounded). Wrap delete in try/catch.",
            "status": "pending",
            "testStrategy": "Test delete shows confirmation dialog. Test successful delete removes file from list. Test failed delete shows error alert. Test download button has correct href and target attributes."
          },
          {
            "id": 4,
            "title": "Add refresh button and loading states for data operations",
            "description": "Implement refresh button in header to reload file list, show loading indicator during operations, and handle API errors gracefully.",
            "dependencies": [
              3
            ],
            "details": "In FilesPage.tsx: (1) Add header section with 'My Files' h1 and refresh button, (2) RefreshCw icon button that calls loadFiles(), (3) setLoading(true) at start of loadFiles, setLoading(false) in finally block, (4) Loading state shows centered spinner div with animate-spin and border-t-2 border-primary-500, (5) Wrap api.getFiles() in try/catch, console.error on failure, (6) Style header with flex justify-between mb-6 matching existing patterns. Add p-6 container wrapper.",
            "status": "pending",
            "testStrategy": "Test refresh button triggers loadFiles. Test loading state displays spinner. Test error in API call is caught and logged. Test refresh updates file list with new data."
          },
          {
            "id": 5,
            "title": "Integrate FilesPage into App.tsx navigation with new 'files' tab",
            "description": "Update App.tsx to add 'files' to activePage state type, add 'My Files' tab button in header navigation, and render FilesPage when files tab is active.",
            "dependencies": [
              4
            ],
            "details": "Modify App.tsx: (1) Import FilesPage from './components/FilesPage', (2) Update activePage state type to include 'files': useState<'paper2figure' | 'paper2ppt' | 'pdf2ppt' | 'ppt2polish' | 'files'>('paper2figure'), (3) Add new tab button after PptPolish with onClick={() => setActivePage('files')}, (4) Style tab button with glass styling when inactive, cyan/teal gradient when active (similar to ppt2polish pattern), (5) Add conditional render: {activePage === 'files' && <FilesPage />} in main content area. Label button as 'My Files'.",
            "status": "pending",
            "testStrategy": "Test clicking 'My Files' tab changes activePage to 'files'. Test FilesPage renders when files tab active. Test tab button styling matches existing tabs. Test navigation between all tabs works correctly."
          },
          {
            "id": 6,
            "title": "UI Design Review - Design File List Page layout",
            "description": "Review existing list/table patterns in codebase. Design file list with columns, actions, and empty states.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 7,
            "title": "Puppeteer E2E Test - Test File List functionality",
            "description": "Use Puppeteer MCP to test: 1) File list renders correctly 2) Download button works 3) Delete with confirmation 4) Empty state display",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 8,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 9,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 10,
            "title": "Implement PM Feedback from Protected Routes review",
            "description": "Address UX issues identified in PM review of Protected Routes. Update quota display, improve navigation, enhance auth state visibility as recommended.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          },
          {
            "id": 11,
            "title": "PM Review - Final UX review of File List",
            "description": "Present File List UI to PM for final UX review. Document feedback on: file list usability, download/delete UX, empty states, loading states.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 22
          }
        ]
      },
      {
        "id": 23,
        "title": "Frontend-Backend Integration Testing",
        "description": "Implement end-to-end integration tests that verify the complete user flow including Supabase Auth with JWT middleware, rate limiting with quota enforcement, and file upload/download functionality work correctly between frontend and backend.",
        "details": "## Implementation Steps\n\n### 1. Create Test Infrastructure\n\n**Create frontend-workflow/tests/e2e/setup.ts**\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\n// Test configuration\nexport const TEST_CONFIG = {\n  SUPABASE_URL: process.env.VITE_SUPABASE_URL!,\n  SUPABASE_KEY: process.env.VITE_SUPABASE_ANON_KEY!,\n  API_URL: process.env.VITE_API_URL || 'http://localhost:8000',\n  TEST_USER_EMAIL: 'integration-test@example.com',\n  TEST_USER_PASSWORD: 'TestPassword123!'\n}\n\nexport const testSupabase = createClient(\n  TEST_CONFIG.SUPABASE_URL,\n  TEST_CONFIG.SUPABASE_KEY\n)\n\n// Helper to get auth headers\nexport async function getAuthHeaders(): Promise<HeadersInit> {\n  const { data: { session } } = await testSupabase.auth.getSession()\n  if (!session) throw new Error('Not authenticated')\n  return {\n    'Authorization': `Bearer ${session.access_token}`,\n    'Content-Type': 'application/json'\n  }\n}\n```\n\n### 2. Auth Integration Tests\n\n**Create frontend-workflow/tests/e2e/auth.test.ts**\n```typescript\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest'\nimport { TEST_CONFIG, testSupabase, getAuthHeaders } from './setup'\n\ndescribe('Auth Integration', () => {\n  let testUserId: string | null = null\n\n  afterAll(async () => {\n    // Cleanup test user if created\n    if (testUserId) {\n      await testSupabase.auth.admin.deleteUser(testUserId)\n    }\n  })\n\n  it('should register a new user', async () => {\n    const { data, error } = await testSupabase.auth.signUp({\n      email: TEST_CONFIG.TEST_USER_EMAIL,\n      password: TEST_CONFIG.TEST_USER_PASSWORD\n    })\n    \n    expect(error).toBeNull()\n    expect(data.user).toBeDefined()\n    expect(data.user?.email).toBe(TEST_CONFIG.TEST_USER_EMAIL)\n    testUserId = data.user?.id || null\n  })\n\n  it('should login with valid credentials', async () => {\n    const { data, error } = await testSupabase.auth.signInWithPassword({\n      email: TEST_CONFIG.TEST_USER_EMAIL,\n      password: TEST_CONFIG.TEST_USER_PASSWORD\n    })\n    \n    expect(error).toBeNull()\n    expect(data.session).toBeDefined()\n    expect(data.session?.access_token).toBeDefined()\n  })\n\n  it('should reject backend API without JWT', async () => {\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/quota`)\n    expect(response.status).toBe(401)\n  })\n\n  it('should accept backend API with valid JWT', async () => {\n    const headers = await getAuthHeaders()\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/quota`, { headers })\n    expect(response.status).toBe(200)\n    \n    const data = await response.json()\n    expect(data).toHaveProperty('used')\n    expect(data).toHaveProperty('limit')\n    expect(data.limit).toBe(10)\n  })\n})\n```\n\n### 3. Rate Limiting Integration Tests\n\n**Create frontend-workflow/tests/e2e/rate-limiting.test.ts**\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { TEST_CONFIG, testSupabase, getAuthHeaders } from './setup'\n\ndescribe('Rate Limiting Integration', () => {\n  beforeEach(async () => {\n    // Login before each test\n    await testSupabase.auth.signInWithPassword({\n      email: TEST_CONFIG.TEST_USER_EMAIL,\n      password: TEST_CONFIG.TEST_USER_PASSWORD\n    })\n  })\n\n  it('should return quota status with used and limit', async () => {\n    const headers = await getAuthHeaders()\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/quota`, { headers })\n    \n    expect(response.status).toBe(200)\n    const data = await response.json()\n    \n    expect(typeof data.used).toBe('number')\n    expect(data.limit).toBe(10)\n    expect(data.used).toBeGreaterThanOrEqual(0)\n    expect(data.used).toBeLessThanOrEqual(10)\n  })\n\n  it('should increment usage count after workflow call', async () => {\n    const headers = await getAuthHeaders()\n    \n    // Get initial quota\n    const beforeRes = await fetch(`${TEST_CONFIG.API_URL}/api/quota`, { headers })\n    const beforeQuota = await beforeRes.json()\n    const initialUsed = beforeQuota.used\n\n    // Skip if already at limit\n    if (initialUsed >= 10) {\n      console.log('Skipping test: quota already exhausted')\n      return\n    }\n\n    // Make a workflow call (using a minimal test endpoint or mock)\n    // Note: In real test, call actual workflow endpoint\n    // For integration test, we might need a test-specific endpoint\n\n    // Verify quota increased\n    const afterRes = await fetch(`${TEST_CONFIG.API_URL}/api/quota`, { headers })\n    const afterQuota = await afterRes.json()\n    \n    // Usage should have increased (if workflow succeeded)\n    // expect(afterQuota.used).toBe(initialUsed + 1)\n  })\n\n  it('should return 429 when quota exhausted', async () => {\n    const headers = await getAuthHeaders()\n    \n    // Get current quota\n    const quotaRes = await fetch(`${TEST_CONFIG.API_URL}/api/quota`, { headers })\n    const quota = await quotaRes.json()\n    \n    if (quota.used < 10) {\n      console.log('Skipping 429 test: need exhausted quota')\n      return\n    }\n\n    // Try to call workflow - should get 429\n    // Note: Replace with actual workflow endpoint\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/paper2figure/generate`, {\n      method: 'POST',\n      headers\n    })\n    \n    expect(response.status).toBe(429)\n  })\n})\n```\n\n### 4. File Upload/Download Integration Tests\n\n**Create frontend-workflow/tests/e2e/files.test.ts**\n```typescript\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest'\nimport { TEST_CONFIG, testSupabase, getAuthHeaders } from './setup'\n\ndescribe('File Management Integration', () => {\n  let createdFileId: string | null = null\n\n  beforeEach(async () => {\n    await testSupabase.auth.signInWithPassword({\n      email: TEST_CONFIG.TEST_USER_EMAIL,\n      password: TEST_CONFIG.TEST_USER_PASSWORD\n    })\n  })\n\n  afterEach(async () => {\n    // Cleanup created test file\n    if (createdFileId) {\n      const headers = await getAuthHeaders()\n      await fetch(`${TEST_CONFIG.API_URL}/api/files/${createdFileId}`, {\n        method: 'DELETE',\n        headers\n      })\n      createdFileId = null\n    }\n  })\n\n  it('should list user files (empty for new user)', async () => {\n    const headers = await getAuthHeaders()\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/files`, { headers })\n    \n    expect(response.status).toBe(200)\n    const data = await response.json()\n    \n    expect(Array.isArray(data)).toBe(true)\n  })\n\n  it('should include download URL in file list', async () => {\n    const headers = await getAuthHeaders()\n    const response = await fetch(`${TEST_CONFIG.API_URL}/api/files`, { headers })\n    const files = await response.json()\n    \n    if (files.length > 0) {\n      const file = files[0]\n      expect(file).toHaveProperty('id')\n      expect(file).toHaveProperty('file_name')\n      expect(file).toHaveProperty('download_url')\n      \n      // Verify download URL is accessible\n      if (file.download_url) {\n        const downloadRes = await fetch(file.download_url)\n        expect([200, 302]).toContain(downloadRes.status)\n      }\n    }\n  })\n\n  it('should delete file successfully', async () => {\n    const headers = await getAuthHeaders()\n    const listRes = await fetch(`${TEST_CONFIG.API_URL}/api/files`, { headers })\n    const files = await listRes.json()\n    \n    if (files.length > 0) {\n      const fileId = files[0].id\n      const deleteRes = await fetch(`${TEST_CONFIG.API_URL}/api/files/${fileId}`, {\n        method: 'DELETE',\n        headers\n      })\n      \n      expect(deleteRes.status).toBe(200)\n      \n      // Verify file is removed from list\n      const verifyRes = await fetch(`${TEST_CONFIG.API_URL}/api/files`, { headers })\n      const updatedFiles = await verifyRes.json()\n      const stillExists = updatedFiles.some((f: any) => f.id === fileId)\n      expect(stillExists).toBe(false)\n    }\n  })\n})\n```\n\n### 5. Backend Integration Tests\n\n**Create fastapi_app/tests/test_integration.py**\n```python\nimport pytest\nfrom httpx import AsyncClient\nfrom fastapi_app.main import app\n\n@pytest.fixture\ndef test_jwt_token():\n    \"\"\"Generate a valid test JWT token from Supabase test user\"\"\"\n    # In real test, authenticate with Supabase and get real token\n    # For now, this is a placeholder\n    return \"test-token-placeholder\"\n\n@pytest.mark.asyncio\nasync def test_quota_endpoint_requires_auth():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/api/quota\")\n        assert response.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_files_endpoint_requires_auth():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/api/files\")\n        assert response.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_workflow_endpoint_requires_auth():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test paper2figure endpoint\n        response = await client.post(\"/api/paper2figure/generate\")\n        assert response.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_quota_returns_correct_format(test_jwt_token):\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        headers = {\"Authorization\": f\"Bearer {test_jwt_token}\"}\n        response = await client.get(\"/api/quota\", headers=headers)\n        \n        # Should be 200 with valid token (or 401 if token invalid in test env)\n        if response.status_code == 200:\n            data = response.json()\n            assert \"used\" in data\n            assert \"limit\" in data\n            assert isinstance(data[\"used\"], int)\n            assert data[\"limit\"] == 10\n```\n\n### 6. Test Configuration Files\n\n**Create frontend-workflow/vitest.config.ts**\n```typescript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['tests/e2e/**/*.test.ts'],\n    testTimeout: 30000,\n    hookTimeout: 30000,\n    setupFiles: ['tests/e2e/setup.ts']\n  }\n})\n```\n\n**Add test scripts to frontend-workflow/package.json**\n```json\n{\n  \"scripts\": {\n    \"test:e2e\": \"vitest run --config vitest.config.ts\",\n    \"test:e2e:watch\": \"vitest --config vitest.config.ts\"\n  },\n  \"devDependencies\": {\n    \"vitest\": \"^1.0.0\"\n  }\n}\n```\n\n### 7. CI/CD Integration Test Script\n\n**Create scripts/run_integration_tests.sh**\n```bash\n#!/bin/bash\nset -e\n\necho \"=== DataFlow-Agent Integration Tests ===\"\n\n# Start backend in background\necho \"Starting FastAPI backend...\"\ncd fastapi_app\nuvicorn main:app --host 0.0.0.0 --port 8000 &\nBACKEND_PID=$!\nsleep 5\n\n# Run backend tests\necho \"Running backend integration tests...\"\npytest tests/test_integration.py -v || true\n\n# Run frontend E2E tests\necho \"Running frontend E2E tests...\"\ncd ../frontend-workflow\nnpm run test:e2e || true\n\n# Cleanup\necho \"Cleaning up...\"\nkill $BACKEND_PID 2>/dev/null || true\n\necho \"=== Integration Tests Complete ===\"\n```\n\n### Key Integration Points Verified\n\n1. **Auth Flow**:\n   - Supabase signUp creates user\n   - Supabase signInWithPassword returns session with JWT\n   - Backend rejects requests without Authorization header (401)\n   - Backend accepts requests with valid Supabase JWT\n\n2. **Rate Limiting**:\n   - /api/quota returns {used, limit} format\n   - Usage count increments after workflow call\n   - Backend returns 429 when daily limit exceeded\n\n3. **File Management**:\n   - /api/files returns user's file list with download URLs\n   - Download URLs are accessible\n   - DELETE /api/files/{id} removes file from list and storage",
        "testStrategy": "## Test Execution Plan\n\n### Prerequisites\n1. Supabase project configured and accessible\n2. Backend running on port 8000\n3. Environment variables set:\n   - `VITE_SUPABASE_URL`\n   - `VITE_SUPABASE_ANON_KEY`\n   - `VITE_API_URL`\n   - Backend: `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`, `SUPABASE_JWT_SECRET`\n\n### Manual Test Checklist\n\n**Auth Tests (Task 15, 19, 20)**\n- [ ] Register new user via frontend form  verify user created in Supabase dashboard\n- [ ] Login via frontend form  verify session stored in localStorage\n- [ ] Call /api/quota without token  expect 401 Unauthorized\n- [ ] Call /api/quota with valid JWT from logged-in user  expect 200 with {used, limit}\n- [ ] Logout  verify session cleared, API calls return 401\n\n**Rate Limiting Tests (Task 16, 18, 21)**\n- [ ] Fresh user shows \": 10/10\" in header\n- [ ] After workflow call, quota decreases to \"9/10\"\n- [ ] With quota at 0, workflow buttons are disabled\n- [ ] With quota at 0, API call returns 429 Too Many Requests\n- [ ] Next day (or after date change), quota resets to 10\n\n**File Management Tests (Task 17, 22)**\n- [ ] After successful workflow, file appears in file list\n- [ ] File list shows: filename, size, date, download button\n- [ ] Click download  file downloads successfully\n- [ ] Click delete  confirmation dialog appears\n- [ ] Confirm delete  file removed from list\n- [ ] Verify file removed from Supabase Storage\n\n### Automated Test Commands\n```bash\n# Run frontend E2E tests\ncd frontend-workflow && npm run test:e2e\n\n# Run backend integration tests\ncd fastapi_app && pytest tests/test_integration.py -v\n\n# Run full integration suite\n./scripts/run_integration_tests.sh\n```\n\n### Expected Results\n- All auth endpoints return correct status codes (401/200)\n- Quota correctly tracks and enforces 10 calls/day limit\n- Files uploaded to Supabase Storage have working download URLs\n- RLS policies prevent cross-user data access\n- Frontend and backend share consistent session state via JWT",
        "status": "pending",
        "dependencies": [
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Test Infrastructure and Dependencies",
            "description": "Install and configure vitest for frontend E2E tests and pytest-httpx for backend integration tests, including all required Supabase testing dependencies.",
            "dependencies": [],
            "details": "Add vitest, @supabase/supabase-js to frontend-workflow/package.json devDependencies. Create vitest.config.ts with node environment, 30s timeouts, and tests/e2e/** include pattern. Add pytest-httpx to requirements-dev.txt for async FastAPI testing. Create frontend-workflow/tests/e2e/setup.ts with TEST_CONFIG (SUPABASE_URL, SUPABASE_KEY, API_URL, TEST_USER credentials), testSupabase client initialization, and getAuthHeaders() helper function. Create scripts/run_integration_tests.sh that starts backend, waits for health check, runs pytest then vitest, and cleans up processes.",
            "status": "pending",
            "testStrategy": "Verify npm run test:e2e runs without configuration errors, pytest tests/test_integration.py collects tests correctly, and run_integration_tests.sh script executes the full test pipeline."
          },
          {
            "id": 2,
            "title": "Implement Supabase Auth Integration Tests",
            "description": "Create E2E tests for the complete authentication flow including user registration, login, session management, and JWT validation against backend API endpoints.",
            "dependencies": [
              1
            ],
            "details": "Create frontend-workflow/tests/e2e/auth.test.ts with test suite: (1) test user registration via supabase.auth.signUp() validates email and returns user object, (2) test login via signInWithPassword() returns valid session with access_token, (3) test backend /api/quota rejects requests without Authorization header (401), (4) test backend /api/quota accepts requests with valid Supabase JWT (200), (5) test session persistence after page refresh simulation. Include afterAll cleanup to delete test user via admin API. Create backend test fastapi_app/tests/test_auth_integration.py to verify JWT middleware rejects invalid tokens, expired tokens, and missing headers.",
            "status": "pending",
            "testStrategy": "Run auth tests in isolation, verify registration creates user in Supabase dashboard, login returns JWT that decodes correctly, and backend correctly validates/rejects tokens."
          },
          {
            "id": 3,
            "title": "Implement Rate Limiting Integration Tests",
            "description": "Create tests verifying quota tracking, usage increments, daily limits, and 429 responses when limits are exceeded.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create frontend-workflow/tests/e2e/rate-limiting.test.ts: (1) test GET /api/quota returns {used: number, limit: 10} format, (2) test usage count increments after successful workflow call, (3) test 429 response when used >= limit. Create helper function to artificially exhaust quota for testing. Create fastapi_app/tests/test_rate_limit_integration.py: (1) test RateLimitService.get_today_count() returns 0 for new user, (2) test record_usage() increments count, (3) test is_limited() returns True when count >= 10, (4) test daily reset by mocking date. Use beforeEach to login test user. Handle edge case where quota already exhausted by skipping or resetting.",
            "status": "pending",
            "testStrategy": "Run rate limiting tests with fresh test user, verify quota increments correctly, mock database to test exhausted quota scenario, verify 429 response includes appropriate error message."
          },
          {
            "id": 4,
            "title": "Implement File Upload/Download Integration Tests",
            "description": "Create tests for file listing, download URL generation, file deletion, and Supabase Storage integration with proper authentication.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create frontend-workflow/tests/e2e/files.test.ts: (1) test GET /api/files returns array of user files with id, file_name, file_size, download_url fields, (2) test download_url is accessible and returns file content, (3) test DELETE /api/files/{id} removes file from list and Supabase Storage, (4) test empty state for user with no files, (5) test file list only shows authenticated user's files (not other users'). Include afterEach cleanup to delete any test files created. Create fastapi_app/tests/test_files_integration.py: (1) test /api/files requires auth, (2) test generate_download_url returns valid signed URL, (3) test file deletion removes from both database and storage.",
            "status": "pending",
            "testStrategy": "Upload test file via Supabase Storage directly in test setup, verify list includes file, download URL works, deletion removes file, and verify cross-user isolation."
          },
          {
            "id": 5,
            "title": "Create CI/CD Integration Test Pipeline and Documentation",
            "description": "Set up GitHub Actions workflow for automated integration tests and document the test execution process for developers.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create .github/workflows/integration-tests.yml: configure job to run on PR to main, set up Node.js 20 and Python 3.11, install dependencies, set Supabase env vars from secrets (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY), start FastAPI in background, run pytest and vitest, upload test reports as artifacts. Create docs/testing/integration-tests.md documenting: test categories (auth, rate-limiting, files), how to run locally, environment setup, debugging failed tests, and how to add new integration tests. Add npm scripts test:e2e and test:e2e:watch to package.json. Ensure CI fails fast on auth test failures since all other tests depend on auth.",
            "status": "pending",
            "testStrategy": "Trigger CI workflow on test branch, verify all jobs complete, check test reports are uploaded, verify PR checks block merge on test failure."
          },
          {
            "id": 6,
            "title": "Code Cleanup - Remove debug code and dirty implementations",
            "description": "Review all code written in this task. Remove console.logs, debug statements, commented code, TODO hacks. Ensure code follows project conventions.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 23
          },
          {
            "id": 7,
            "title": "Git Commit - Commit all changes (no push)",
            "description": "Stage and commit all changes for this task with descriptive message. DO NOT push to remote. Format: 'feat(scope): description'",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 23
          },
          {
            "id": 8,
            "title": "Implement Final PM Feedback",
            "description": "Address any remaining UX issues from final PM review. Polish all UI components based on feedback before integration testing.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 23
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-12-26T17:31:20.185Z",
      "updated": "2025-12-26T18:11:00.118Z",
      "description": "Tasks for master context"
    }
  }
}